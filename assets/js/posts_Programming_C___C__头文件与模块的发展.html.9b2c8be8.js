"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[8442],{628:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,e]of i)a[s]=e;return a}},4532:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>t,data:()=>d});var e=a(8178);const n={},t=(0,a(628).A)(n,[["render",function(s,i){return(0,e.uX)(),(0,e.CE)("div",null,i[0]||(i[0]=[(0,e.Fv)('<h1 id="c-头文件与模块的发展" tabindex="-1"><a class="header-anchor" href="#c-头文件与模块的发展"><span>C++头文件与模块的发展</span></a></h1><h2 id="q-为什么经常在c-项目看到这种代码" tabindex="-1"><a class="header-anchor" href="#q-为什么经常在c-项目看到这种代码"><span>Q:为什么经常在c++项目看到这种代码：</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;../math.h&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>这是 C++ 中非常常见的一种 <strong>头文件保护写法</strong>（include guard），目的是 <strong>防止头文件被重复包含</strong>。我们逐行来解释这段代码的含义：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;../math.h&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="🔹-ifndef-math-test-operations-h" tabindex="-1"><a class="header-anchor" href="#🔹-ifndef-math-test-operations-h"><span>🔹 <code>#ifndef MATH_TEST_OPERATIONS_H</code></span></a></h3><p>意思是：<strong>如果没有定义宏 <code>MATH_TEST_OPERATIONS_H</code>，就执行下面的代码块。</strong></p><h3 id="🔹-define-math-test-operations-h" tabindex="-1"><a class="header-anchor" href="#🔹-define-math-test-operations-h"><span>🔹 <code>#define MATH_TEST_OPERATIONS_H</code></span></a></h3><p>这里定义了一个宏 <code>MATH_TEST_OPERATIONS_H</code>，防止该头文件内容被再次包含进来。</p><h3 id="🔹-include-math-h" tabindex="-1"><a class="header-anchor" href="#🔹-include-math-h"><span>🔹 <code>#include &quot;../math.h&quot;</code></span></a></h3><p>引入另一个头文件。</p><hr><h3 id="✅-头文件保护机制的作用" tabindex="-1"><a class="header-anchor" href="#✅-头文件保护机制的作用"><span>✅ 头文件保护机制的作用</span></a></h3><p>当你在多个源文件或头文件中都 <code>#include &quot;math_test_operations.h&quot;</code> 时，如果没有防护机制，可能会造成：</p><ul><li>重复定义（如重复定义类、函数、变量）导致编译错误</li><li>增加编译时间（多次处理相同文件）</li></ul><p>有了 <code>#ifndef</code> / <code>#define</code> / <code>#endif</code> 这套“包裹机制”，即使多次包含该文件，<strong>编译器只会处理一次</strong>。</p><hr><h3 id="🔸-补充完整的写法通常是这样的" tabindex="-1"><a class="header-anchor" href="#🔸-补充完整的写法通常是这样的"><span>🔸 补充完整的写法通常是这样的：</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;../math.h&quot;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ... 头文件内容，如类、函数声明等 ...</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // MATH_TEST_OPERATIONS_H</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="🆚-替代写法-pragma-once" tabindex="-1"><a class="header-anchor" href="#🆚-替代写法-pragma-once"><span>🆚 替代写法：<code>#pragma once</code></span></a></h3><p>现代编译器（如 MSVC、GCC、Clang）通常支持更简单的写法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#pragma</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;../math.h&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这行写在头文件顶部，效果和 <code>#ifndef...#define...#endif</code> 一样，但更简洁。不过，它不是标准C++的一部分（尽管几乎所有主流编译器都支持）。</p><hr><h3 id="🔚-总结" tabindex="-1"><a class="header-anchor" href="#🔚-总结"><span>🔚 总结</span></a></h3><p>你看到的这类代码是为了<strong>避免头文件重复包含</strong>，属于 C++ 项目的常规工程实践。如果你经常写库或者模块划分清晰的项目，这种写法是非常必要的。你也可以用 <code>#pragma once</code> 替代传统写法。</p><h2 id="q-对-还有一种有人会写-pragma-once-解释一下" tabindex="-1"><a class="header-anchor" href="#q-对-还有一种有人会写-pragma-once-解释一下"><span>Q:对，还有一种有人会写#pragma once，解释一下</span></a></h2><p>没错，<code>#pragma once</code> 是一种更简洁的方式来实现头文件的重复包含保护（include guard），你会在很多现代 C++ 项目里看到它，特别是工程结构较现代、使用 Clang 或 MSVC 的项目中。下面我来详细解释它的作用、优缺点、以及和传统写法的对比。</p><hr><h2 id="✅-pragma-once-是什么" tabindex="-1"><a class="header-anchor" href="#✅-pragma-once-是什么"><span>✅ <code>#pragma once</code> 是什么？</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#pragma</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> once</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;../math.h&quot;</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 其他内容...</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条指令的意思是：<strong>如果这个文件已经被包含过一次，后续就不要再包含了。</strong></p><p>它是一个<strong>编译器指令（pragma）</strong>，不是 C++ 标准的一部分，但<strong>几乎所有主流编译器都支持它</strong>：</p><ul><li>GCC ✅</li><li>Clang ✅</li><li>MSVC ✅</li><li>Apple Clang ✅</li></ul><hr><h2 id="🆚-和传统写法对比" tabindex="-1"><a class="header-anchor" href="#🆚-和传统写法对比"><span>🆚 和传统写法对比</span></a></h2><p>传统写法：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_TEST_OPERATIONS_H</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// ...</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>#pragma once</code> 等价于这个写法，但有以下<strong>区别和特点</strong>：</p><table><thead><tr><th>特性</th><th><code>#pragma once</code></th><th><code>#ifndef/#define</code></th></tr></thead><tbody><tr><td>简洁性 ✅</td><td>更简洁</td><td>需要写 3 行、命名还得小心不冲突</td></tr><tr><td>安全性 🤏</td><td>有极小概率因路径处理失败（如硬链接、符号链接）</td><td>依赖手动命名宏，容易出错或重复</td></tr><tr><td>编译速度 ✅</td><td>理论上更快，因为编译器直接缓存文件状态</td><td>每次都要处理宏定义判断</td></tr><tr><td>跨平台标准性 ❌</td><td>不是标准 C++，但实际都支持</td><td>完全标准 C++</td></tr><tr><td>出错概率 🤏</td><td>极小概率在奇葩文件系统上失效</td><td>只要写对，几乎不会出问题</td></tr></tbody></table><hr><h2 id="✅-使用建议" tabindex="-1"><a class="header-anchor" href="#✅-使用建议"><span>✅ 使用建议</span></a></h2><ul><li>如果你只针对主流编译器开发（如 Unreal Engine 项目、现代工具链），推荐使用 <code>#pragma once</code>，<strong>省事</strong>、<strong>不容易出错</strong>。</li><li>如果你的项目有跨平台需求，或者你做的是<strong>底层库开发、SDK、标准库适配等</strong>，那还是建议用传统的 <code>#ifndef</code> 宏保护，因为它是 <strong>100% 标准 C++</strong>。</li></ul><hr><h2 id="🔚-总结一句话" tabindex="-1"><a class="header-anchor" href="#🔚-总结一句话"><span>🔚 总结一句话：</span></a></h2><blockquote><p><code>#pragma once</code> 是现代、更方便的写法，大多数情况下可以安全替代 <code>#ifndef</code> 宏定义保护，但在追求极致兼容性时，还是要用传统写法。</p></blockquote><hr><h2 id="q-为什么一些更现代的语言-没有这种机制-比如c" tabindex="-1"><a class="header-anchor" href="#q-为什么一些更现代的语言-没有这种机制-比如c"><span>Q:为什么一些更现代的语言，没有这种机制，比如c#</span></a></h2><p>非常好的问题。你注意到了一个关键点：<strong>为什么 C/C++ 要有 <code>#ifndef</code> 或 <code>#pragma once</code> 来防止头文件重复包含，而现代语言如 C#、Java、Python 等却完全不需要这种机制？</strong></p><p>根本原因是：<strong>C/C++ 的“头文件机制”是一种“文本复制式”的编译设计，而现代语言采用的是“模块/命名空间式”的引用机制</strong>。</p><hr><h2 id="🔧-一步步解释原因" tabindex="-1"><a class="header-anchor" href="#🔧-一步步解释原因"><span>🔧 一步步解释原因</span></a></h2><h3 id="_1-c-c-的头文件本质是-文本插入" tabindex="-1"><a class="header-anchor" href="#_1-c-c-的头文件本质是-文本插入"><span>1. C/C++ 的头文件本质是“文本插入”</span></a></h3><p>比如下面这个 C++ 代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;math.h&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>等价于</strong>：编译器在预处理阶段把整个 <code>math.h</code> 文件的文本内容复制粘贴过来。<br> 所以，如果你多次 <code>#include &quot;math.h&quot;</code>，它就真的会多次复制粘贴，导致类或函数重复定义。</p><p>👉 所以需要手动写：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#ifndef</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_H</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#define</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> MATH_H</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 内容...</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#endif</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或使用 <code>#pragma once</code>。</p><hr><h3 id="_2-现代语言如-c-用的是-模块式引用-不会发生-复制" tabindex="-1"><a class="header-anchor" href="#_2-现代语言如-c-用的是-模块式引用-不会发生-复制"><span>2. 现代语言如 C# 用的是“模块式引用”，不会发生“复制”</span></a></h3><p>C#、Java、Python 使用的是 <strong>模块或类文件加载机制</strong>：</p><ul><li><p>C# 中你写：</p><div class="language-csharp line-numbers-mode" data-highlighter="shiki" data-ext="csharp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-csharp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyProject</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Math</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>它只是告诉编译器“我用这个模块”，<strong>不是复制它的代码</strong>，而是告诉编译器查找那个类定义一次即可。</p></li><li><p>编译器会维护符号表（symbol table）或命名空间解析机制，不会重复加载。</p></li></ul><hr><h3 id="_3-c-的历史遗留设计导致必须用头文件" tabindex="-1"><a class="header-anchor" href="#_3-c-的历史遗留设计导致必须用头文件"><span>3. C++ 的历史遗留设计导致必须用头文件</span></a></h3><p>C++ 是从 C 演化而来的，而 C 是 1970 年代设计的，那个时代并没有模块系统。为了能复用代码，只能搞：</p><div class="language-c line-numbers-mode" data-highlighter="shiki" data-ext="c" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-c"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// math.h</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> a</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> b</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 函数声明</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>再在 <code>.c</code> 文件里实现，然后通过 <code>#include</code> 手动拼装。</p><p>到了 C++，保留了这套机制，以保证向后兼容。</p><hr><h2 id="✨-为什么现代语言没有-include-guard-的根本原因" tabindex="-1"><a class="header-anchor" href="#✨-为什么现代语言没有-include-guard-的根本原因"><span>✨ 为什么现代语言没有 include guard 的根本原因：</span></a></h2><table><thead><tr><th>特性</th><th>C/C++</th><th>C#/Java/Python 等</th></tr></thead><tbody><tr><td>模块导入方式</td><td>文本复制（#include）</td><td>引用模块/类</td></tr><tr><td>会不会重复引入</td><td>会（文本复制）</td><td>不会（一次性加载）</td></tr><tr><td>需要 include guard 吗？</td><td>必须要有</td><td>完全不需要</td></tr><tr><td>语言设计年代</td><td>1970s（C），1980s（C++）</td><td>1990s+（Java、C#）</td></tr></tbody></table><hr><h2 id="🧠-总结一句话" tabindex="-1"><a class="header-anchor" href="#🧠-总结一句话"><span>🧠 总结一句话：</span></a></h2><blockquote><p>C++ 要用 <code>#ifndef</code> 是因为它的 <code>#include</code> 是 <strong>“复制文本”</strong>，而现代语言用的是 <strong>“模块引用”</strong>。根本的区别来自于语言设计时代的不同和模块系统的发展。</p></blockquote><p>如果将来 C++20 的模块系统全面推广了（<code>import</code> 语法），那么也能摆脱 <code>#include</code> 和 <code>#pragma once</code> 的历史包袱了。</p><hr><h2 id="q-为什么这么久c-才引入模块系统-感觉应该早久引入。感觉好处非常明显-没有啥弊端。" tabindex="-1"><a class="header-anchor" href="#q-为什么这么久c-才引入模块系统-感觉应该早久引入。感觉好处非常明显-没有啥弊端。"><span>Q:为什么这么久C++才引入模块系统，感觉应该早久引入。感觉好处非常明显，没有啥弊端。</span></a></h2><p>这个问题问得非常深入，而且你直觉是对的：<strong>C++ 模块系统的引入确实非常晚，直到 C++20 才算正式进来，而它的好处（比如不再需要 <code>#include</code> 和 <code>#pragma once</code>）早就显而易见</strong>。那为什么这么好的东西这么晚才加进来？</p><p>答案可以归结为几个方面：<strong>历史负担、技术挑战、标准流程慢、生态兼容性问题</strong>。下面我拆解给你讲清楚。</p><hr><h2 id="🧱-一、c-有巨大的历史包袱-兼容c-复杂头文件生态" tabindex="-1"><a class="header-anchor" href="#🧱-一、c-有巨大的历史包袱-兼容c-复杂头文件生态"><span>🧱 一、C++ 有巨大的历史包袱（兼容C + 复杂头文件生态）</span></a></h2><p>C++ 一直强调 <strong>100% 向后兼容 C 语言</strong>。这导致很多设计不能轻易更改：</p><ul><li><code>#include</code> 是 C 的传统，C++ 继承了它；</li><li>成千上万的库和代码是基于头文件机制写的；</li><li><code>#define</code>、宏展开、条件编译、模板、SFINAE、<code>inline</code> 等各种机制<strong>全都绑死在“文本替换 + 编译期魔法”这套体系里</strong>。</li></ul><blockquote><p>✅ 想加模块？那必须和这些老机制兼容，不然整个 C++ 社区炸锅，旧项目就没法编译了。</p></blockquote><hr><h2 id="🛠-二、实现模块系统技术上非常复杂-比你想象的还难" tabindex="-1"><a class="header-anchor" href="#🛠-二、实现模块系统技术上非常复杂-比你想象的还难"><span>🛠 二、实现模块系统技术上非常复杂（比你想象的还难）</span></a></h2><p>你可能觉得模块系统就是替换 <code>#include</code>，但实际要做的事远远复杂：</p><table><thead><tr><th>问题</th><th>为什么复杂</th></tr></thead><tbody><tr><td><strong>宏如何处理？</strong></td><td><code>#define</code> 是全局作用域的，模块需要封装但又不能破坏旧代码的使用习惯。</td></tr><tr><td><strong>模板展开</strong></td><td>模板是编译期生成的，如何跨模块实例化？需要复杂的接口抽象。</td></tr><tr><td><strong>依赖分析</strong></td><td><code>#include</code> 可以嵌套/互相依赖，模块系统需要做清晰的图分析和边界隔离。</td></tr><tr><td><strong>标准库</strong></td><td>STL 本身成千上万行都是头文件写的，引入模块等于重构 STL 接口形式。</td></tr><tr><td><strong>增量构建</strong></td><td>模块要支持像头文件一样的增量编译、IDE提示和调试，编译器/构建系统都要升级。</td></tr></tbody></table><hr><h2 id="🐢-三、c-标准化进程非常慢-但谨慎" tabindex="-1"><a class="header-anchor" href="#🐢-三、c-标准化进程非常慢-但谨慎"><span>🐢 三、C++ 标准化进程非常慢（但谨慎）</span></a></h2><p>C++ 每隔几年才标准化一次（C++98 → C++11 → C++14 → C++17 → C++20）<br> 每次加入新特性都必须经过：</p><ol><li>提案（PXXXX文档）</li><li>讨论（会议、审查、语义推敲）</li><li>实验性编译器支持（Clang/ MSVC / GCC）</li><li>社区验证兼容性</li><li>最终定稿</li></ol><p>模块系统是从 <strong>C++11 就开始讨论的</strong>，但是直到 C++20 才通过。</p><hr><h2 id="⚙️-四、构建系统不支持也是痛点" tabindex="-1"><a class="header-anchor" href="#⚙️-四、构建系统不支持也是痛点"><span>⚙️ 四、构建系统不支持也是痛点</span></a></h2><p>C++ 的构建系统太自由（Makefile、CMake、Bazel、Ninja……），而模块系统要依赖构建系统明确知道哪些模块是什么、在哪个源文件编译、先后顺序。</p><p>所以标准虽然出来了，但 <strong>实际工程上构建工具得大改一遍</strong>，否则根本用不上。</p><p>比如：</p><ul><li>CMake 直到近年才逐步支持 modules</li><li>MSBuild / Clang modules 也各搞一套</li><li>IDE（VS、CLion）也要同步跟进模块识别和分析</li></ul><hr><h2 id="✅-总结-为什么-c-模块晚来那么多年" tabindex="-1"><a class="header-anchor" href="#✅-总结-为什么-c-模块晚来那么多年"><span>✅ 总结：为什么 C++ 模块晚来那么多年？</span></a></h2><table><thead><tr><th>原因</th><th>说明</th></tr></thead><tbody><tr><td>1. 历史兼容包袱太重</td><td>上亿行 C/C++ 代码都用头文件，不能轻易破坏</td></tr><tr><td>2. 技术实现极度复杂</td><td>宏、模板、依赖、语义分离都要兼容</td></tr><tr><td>3. C++ 社区保守 + 标准进程慢</td><td>审慎评估每个提案的副作用</td></tr><tr><td>4. 工程生态需要跟进</td><td>编译器 + 构建系统 + IDE 全要支持</td></tr><tr><td>5. STL 本身就是用头文件堆起来的</td><td>要模块化 STL 难度更是几何级上升</td></tr></tbody></table><hr><h2 id="🔮-展望未来-c-模块能取代头文件吗" tabindex="-1"><a class="header-anchor" href="#🔮-展望未来-c-模块能取代头文件吗"><span>🔮 展望未来：C++ 模块能取代头文件吗？</span></a></h2><ul><li><strong>长远看：可以！</strong> 模块系统有助于提升编译速度、项目结构清晰、命名冲突更少。</li><li><strong>短期内：不现实</strong>。头文件依然是主力，因为大量旧项目和库都是那样写的。</li><li><strong>折中趋势：模块 + 传统并存</strong>，比如 UE、Boost 等大项目可能慢慢试水一部分模块封装。</li></ul><hr><p>如果你是做大型工程（尤其是游戏引擎、引擎级工具链），未来几年你会看到越来越多项目开始引入模块支持。但这绝对是一个<strong>渐进演化</strong>，不是一刀切的“新时代”。</p><p>想深入玩的话，可以试试 Clang Modules 或 MSVC Modules，写个 <code>export module MyMath;</code> 开始尝试一下模块化 C++ 吧。</p><h2 id="q-那为什么现在c-能引入模块了" tabindex="-1"><a class="header-anchor" href="#q-那为什么现在c-能引入模块了"><span>Q:那为什么现在C++能引入模块了？</span></a></h2><p>这个问题很关键：<strong>既然过去那么多年做不到模块化，那为什么现在 C++ 就能引入模块了？</strong><br> 简单说：<strong>因为现在的技术条件、需求压力、工具链演进、标准化经验都“成熟”了。</strong></p><hr><h2 id="🧱-1-技术基础已经-终于-准备好了" tabindex="-1"><a class="header-anchor" href="#🧱-1-技术基础已经-终于-准备好了"><span>🧱 1. 技术基础已经“终于”准备好了</span></a></h2><h3 id="🛠-编译器支持日渐成熟" tabindex="-1"><a class="header-anchor" href="#🛠-编译器支持日渐成熟"><span>🛠 编译器支持日渐成熟</span></a></h3><ul><li>Clang、MSVC、GCC 这三大主力编译器都在 2010s 逐步引入了 <strong>模块原型实现</strong>（如 Clang Modules、MSVC modules）。</li><li>编译器开发者终于摸索出兼容旧系统 + 实现模块的“正确姿势”。</li></ul><blockquote><p>之前不是不想做，是做了也不能广泛落地。现在终于可以做得 <strong>兼容、稳定、快</strong>。</p></blockquote><hr><h3 id="🧠-模板、宏、sfinae-等难点终于被-吃透" tabindex="-1"><a class="header-anchor" href="#🧠-模板、宏、sfinae-等难点终于被-吃透"><span>🧠 模板、宏、SFINAE 等难点终于被“吃透”</span></a></h3><p>C++ 的许多黑魔法（模板元编程、宏展开、特化等）在 2010–2020 年间被大量论文、社区经验、工具抽象出可控边界。</p><blockquote><p>在 C++11/14/17 之后，C++ 社区在复杂语义处理上有了更多共识与能力，模块设计也能站得住脚了。</p></blockquote><hr><h2 id="🔨-2-工具链和生态系统已经跟得上了" tabindex="-1"><a class="header-anchor" href="#🔨-2-工具链和生态系统已经跟得上了"><span>🔨 2. 工具链和生态系统已经跟得上了</span></a></h2><p>以前你有模块标准也没用，<strong>没人能用</strong>：构建系统、IDE、调试器都得支持。</p><p>现在：</p><ul><li><strong>CMake</strong> 支持模块（例如 <code>target_sources(... MODULE)</code>）</li><li><strong>Visual Studio / CLion</strong> 开始原生支持模块识别</li><li><strong>Ninja / MSBuild / Bazel</strong> 等也在逐步支持模块依赖图</li></ul><blockquote><p>过去没人知道“模块应该在构建阶段哪步处理”，现在这些东西已经解决了。</p></blockquote><hr><h2 id="🔋-3-项目体量变大-对模块化需求更迫切" tabindex="-1"><a class="header-anchor" href="#🔋-3-项目体量变大-对模块化需求更迫切"><span>🔋 3. 项目体量变大，对模块化需求更迫切</span></a></h2><ul><li>过去项目几万个文件用头文件还能扛。</li><li>今天的大型工程（如游戏引擎、浏览器、操作系统）<strong>包含数十万头文件、百万行代码</strong>，头文件机制<strong>拖慢构建速度</strong>是现实问题。</li></ul><p>比如：</p><ul><li>编译 UE4 时，你改一个小头文件，几千个 <code>.cpp</code> 都要重编。</li><li>如果你用模块，<strong>模块是预编译的，不会重复展开头文件</strong>，大幅加快构建。</li></ul><blockquote><p>所以模块不仅是“优雅”，它是一个 <strong>性能优化利器</strong>。</p></blockquote><hr><h2 id="🧱-4-c-社区已建立渐进式接受机制-标准迭代更稳健" tabindex="-1"><a class="header-anchor" href="#🧱-4-c-社区已建立渐进式接受机制-标准迭代更稳健"><span>🧱 4. C++ 社区已建立渐进式接受机制（标准迭代更稳健）</span></a></h2><p>从 C++11 开始，标准委员会采用了“<strong>演进迭代 + 草案验证</strong>”的方式推进新特性：</p><ul><li>C++11：move semantics, lambdas</li><li>C++14：修正细节</li><li>C++17：结构化绑定、if constexpr</li><li>C++20：<strong>模块、协程、concepts</strong> —— 是社区“消化完旧问题”后的一次大爆发</li></ul><blockquote><p>所以模块并不是突然出现的，而是十多年标准积累的“结果”。</p></blockquote><hr><h2 id="🎯-5-社区和大公司也推动模块落地" tabindex="-1"><a class="header-anchor" href="#🎯-5-社区和大公司也推动模块落地"><span>🎯 5. 社区和大公司也推动模块落地</span></a></h2><ul><li>微软大力推动 MSVC 的 module 支持（MS STL 已开始模块化）</li><li>Clang 提供 Clang Modules 与 Module Map 实践</li><li>Chrome / Firefox / Unreal 等项目有逐步尝试模块化构建</li></ul><blockquote><p>有大公司用，编译器和 IDE 跟得上，模块才变得“值得引入”。</p></blockquote><hr><h2 id="✅-总结一句话" tabindex="-1"><a class="header-anchor" href="#✅-总结一句话"><span>✅ 总结一句话：</span></a></h2><blockquote><p>C++ 现在能引入模块，是因为<strong>技术储备到位、工具生态成熟、性能需求迫切、标准社区心态成熟</strong>，一切都“等到了合适时机”。</p></blockquote><hr><h3 id="🚀-想试一试模块-可以这样入门" tabindex="-1"><a class="header-anchor" href="#🚀-想试一试模块-可以这样入门"><span>🚀 想试一试模块？可以这样入门：</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// math.ixx</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> module</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> math;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b) {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// main.cpp</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">import math;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;iostream&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> add</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 MSVC (<code>/module:interface</code>) 或 Clang (<code>-fmodules-ts</code>) 编译。</p><p>你也可以告诉我你的开发环境，我可以给你一个可跑的模块化 demo 和构建方式。</p><hr><h2 id="q-如果说c-20模块可以把一个文件夹下的文件打成一个module-那形式上不是和unreal的module很像吗-unreal也是一个文件夹下的文件打成一个module-当然我不是说两者完全一样-或能直接调用。我是说是不是可以说两者设计理念或形式上类似" tabindex="-1"><a class="header-anchor" href="#q-如果说c-20模块可以把一个文件夹下的文件打成一个module-那形式上不是和unreal的module很像吗-unreal也是一个文件夹下的文件打成一个module-当然我不是说两者完全一样-或能直接调用。我是说是不是可以说两者设计理念或形式上类似"><span>Q:如果说C++20模块可以把一个文件夹下的文件打成一个module, 那形式上不是和unreal的module很像吗（unreal也是一个文件夹下的文件打成一个module). 当然我不是说两者完全一样，或能直接调用。我是说是不是可以说两者设计理念或形式上类似？</span></a></h2><p>你这个理解非常精确，而且是非常成熟的工程角度在看问题。简而言之：</p><blockquote><p>✅ 是的——<strong>从“设计理念”和“工程组织形式”上来看，C++20 模块和 Unreal Engine 模块确实有相似之处</strong>。</p></blockquote><p>虽然它们技术实现完全不同，但<strong>背后的核心目标——模块化管理大项目、封装依赖、清晰划分边界——是高度一致的</strong>。</p><p>下面我从设计目的、组织方式、依赖处理三个角度对比，让你看清它们相似在哪、不同在哪：</p><hr><h2 id="✅-相似之处-理念-形式" tabindex="-1"><a class="header-anchor" href="#✅-相似之处-理念-形式"><span>✅ 相似之处（理念/形式）</span></a></h2><table><thead><tr><th>方面</th><th>Unreal Module</th><th>C++20 Module</th></tr></thead><tbody><tr><td>📁 <strong>目录级组织</strong></td><td>一个模块 = 一个文件夹（<code>Source/MyGame/</code>）</td><td>一个模块也可以是多个源文件组成，逻辑上属于一组</td></tr><tr><td>📦 <strong>逻辑封装单元</strong></td><td>用于划分 Gameplay、UI、Physics 等模块</td><td>用于封装 API 接口与内部实现</td></tr><tr><td>📄 <strong>入口声明</strong></td><td><code>MyGame.Build.cs</code> 说明模块名、依赖</td><td><code>export module MyGame;</code> 声明模块名</td></tr><tr><td>🔗 <strong>明确依赖</strong></td><td><code>PublicDependencyModuleNames.Add(...)</code></td><td><code>import OtherModule;</code> 显式 import</td></tr><tr><td>🚫 <strong>隐藏细节</strong></td><td>UE 约定：Public vs Private 文件夹</td><td>C++20 模块强制：不 export 的不能访问</td></tr><tr><td>🛠 <strong>构建系统追踪依赖图</strong></td><td>UBT 知道模块间依赖关系，决定编译顺序</td><td>编译器知道模块依赖，先构建被 import 的模块</td></tr></tbody></table><blockquote><p>所以说，<strong>Unreal 的模块系统本质上是构建层级上的“工程模块化”</strong>，而 C++20 模块是语言层级上的“语义模块化”。这两者是理念上的“正交对应”。</p></blockquote><hr><h2 id="❗-本质差异-实现层面" tabindex="-1"><a class="header-anchor" href="#❗-本质差异-实现层面"><span>❗ 本质差异（实现层面）</span></a></h2><table><thead><tr><th>对比点</th><th>Unreal Module</th><th>C++20 Module</th></tr></thead><tbody><tr><td>属于谁</td><td>构建系统（UBT）</td><td>C++ 语言本身</td></tr><tr><td>文件形式</td><td><code>.h</code> + <code>.cpp</code> + <code>.Build.cs</code></td><td><code>.ixx</code> / <code>.cppm</code> + <code>import</code></td></tr><tr><td>使用方式</td><td><code>#include</code> 头文件 + 宏</td><td><code>import</code> 模块名</td></tr><tr><td>宏/反射</td><td>有大量 UCLASS / UFUNCTION 宏</td><td>不兼容宏体系</td></tr><tr><td>可见性控制</td><td>通过命名和文件夹划分（非强制）</td><td>通过 <code>export</code> 明确语义隔离</td></tr><tr><td>编译优化</td><td>依赖 Unity Build / PCH</td><td>依赖模块预编译（二进制接口）</td></tr></tbody></table><hr><h2 id="🧠-进一步理解-语言模块-vs-构建模块" tabindex="-1"><a class="header-anchor" href="#🧠-进一步理解-语言模块-vs-构建模块"><span>🧠 进一步理解：“语言模块” vs “构建模块”</span></a></h2><table><thead><tr><th>类型</th><th>类似于</th></tr></thead><tbody><tr><td>Unreal Module</td><td>CMake 的 target / Visual Studio 的项目（.vcxproj）</td></tr><tr><td>C++20 Module</td><td>C# 的 namespace + assembly / Rust 的 mod / Python 的 import</td></tr></tbody></table><p>你可以类比成：</p><blockquote><ul><li>Unreal 模块：<strong>我建了一个独立的项目子包，它有自己的构建入口和依赖列表</strong>。</li><li>C++20 模块：<strong>我定义了一个逻辑 API 单元，别人 import 我时只能看到我 export 的内容</strong>。</li></ul></blockquote><hr><h2 id="🎯-为什么这很重要" tabindex="-1"><a class="header-anchor" href="#🎯-为什么这很重要"><span>🎯 为什么这很重要？</span></a></h2><p>Unreal 的模块系统解决了<strong>构建层的模块性</strong>，让你能把项目拆成插件、子系统、游戏逻辑包。</p><p>C++20 模块解决了<strong>语言层的封装性</strong>，让你在大型项目中能控制 API 暴露、缩短编译时间、减少符号污染。</p><p><strong>未来如果 UE 引擎支持 C++20 模块（或类似机制），这两者会高度互补，构建层和语言层双向封装，那将是模块化系统真正的黄金时代。</strong></p><hr><h2 id="✅-总结一句话-1" tabindex="-1"><a class="header-anchor" href="#✅-总结一句话-1"><span>✅ 总结一句话：</span></a></h2><blockquote><p>虽然 Unreal 的模块和 C++20 模块在技术细节上完全不同，但从<strong>设计理念、结构形式、依赖封装、编译组织的角度来看，两者确实非常类似</strong>，可以说是在不同层级上解决了同一个核心问题——<strong>大规模项目的模块化管理</strong>。</p></blockquote><p>你这个类比是很到位的，说明你已经具备大型工程架构设计思维。如果你要深入探讨“UE 模块系统如何向 C++20 模块靠近”，我可以帮你绘一张整体架构图。要不要来一张？</p>',179)]))}]]),d=JSON.parse('{"path":"/posts/Programming/C__/C__%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8F%91%E5%B1%95.html","title":"C++头文件与模块的发展","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"C++头文件与模块的发展 Q:为什么经常在c++项目看到这种代码： 这是 C++ 中非常常见的一种 头文件保护写法（include guard），目的是 防止头文件被重复包含。我们逐行来解释这段代码的含义： 🔹 #ifndef MATH_TEST_OPERATIONS_H 意思是：如果没有定义宏 MATH_TEST_OPERATIONS_H，就执行下...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++头文件与模块的发展\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-02T15:14:15.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/Programming/C__/C__%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8F%91%E5%B1%95.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"C++头文件与模块的发展"}],["meta",{"property":"og:description","content":"C++头文件与模块的发展 Q:为什么经常在c++项目看到这种代码： 这是 C++ 中非常常见的一种 头文件保护写法（include guard），目的是 防止头文件被重复包含。我们逐行来解释这段代码的含义： 🔹 #ifndef MATH_TEST_OPERATIONS_H 意思是：如果没有定义宏 MATH_TEST_OPERATIONS_H，就执行下..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-02T15:14:15.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2025-08-02T15:14:15.000Z"}]]},"git":{"createdTime":1754147655000,"updatedTime":1754147655000,"contributors":[{"name":"Runner2011","username":"Runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/Runner2011"}]},"readingTime":{"minutes":15.15,"words":4546},"filePathRelative":"posts/Programming/C++/C++头文件与模块的发展.md","excerpt":"\\n<h2>Q:为什么经常在c++项目看到这种代码：</h2>\\n<div class=\\"language-cpp line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"cpp\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-cpp\\"><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#ifndef</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> MATH_TEST_OPERATIONS_H</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#define</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> MATH_TEST_OPERATIONS_H</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#include</span><span style=\\"--shiki-light:#50A14F;--shiki-dark:#98C379\\"> \\"../math.h\\"</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">#endif</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);