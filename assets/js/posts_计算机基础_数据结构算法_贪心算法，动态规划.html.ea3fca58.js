"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[5363],{628:(t,s)=>{s.A=(t,s)=>{const a=t.__vccOpts||t;for(const[t,n]of s)a[t]=n;return a}},6021:(t,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>p});var n=a(8178);const e={},l=(0,a(628).A)(e,[["render",function(t,s){const a=(0,n.g2)("RouteLink");return(0,n.uX)(),(0,n.CE)("div",null,[s[7]||(s[7]=(0,n.Lk)("h1",{id:"贪心算法-动态规划",tabindex:"-1"},[(0,n.Lk)("a",{class:"header-anchor",href:"#贪心算法-动态规划"},[(0,n.Lk)("span",null,"贪心算法，动态规划")])],-1)),s[8]||(s[8]=(0,n.Lk)("ul",null,[(0,n.Lk)("li",null,[(0,n.Lk)("strong",null,"贪心算法"),(0,n.eW)("：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。")]),(0,n.Lk)("li",null,[(0,n.Lk)("strong",null,"动态规划"),(0,n.eW)("：像一群人分头探索所有路径，最后汇总最优路线")])],-1)),(0,n.Lk)("p",null,[s[1]||(s[1]=(0,n.eW)("动态规划：计算每一个子问题，并记录子问题的结果。")),s[2]||(s[2]=(0,n.Lk)("strong",null,"核心：子问题只算一遍。",-1)),s[3]||(s[3]=(0,n.eW)(" 这个方式来降复杂度，而")),(0,n.bF)(a,{to:"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html"},{default:(0,n.k6)(()=>s[0]||(s[0]=[(0,n.eW)("NP问题")])),_:1,__:[0]}),s[4]||(s[4]=(0,n.eW)("通常不能拆分成")),s[5]||(s[5]=(0,n.Lk)("strong",null,"可复用的子问题",-1)),s[6]||(s[6]=(0,n.eW)("，导致复杂度太高"))]),s[9]||(s[9]=(0,n.Fv)('<p>贪心算法：每次取最解决的结果，一条路走到黑</p><h2 id="贪心算法的问题" tabindex="-1"><a class="header-anchor" href="#贪心算法的问题"><span>贪心算法的问题</span></a></h2><ul><li>是一种快速接近最优解的办法，但可能不是最优解</li><li>动态规划因为考虑了全局（在满足某些条件，暂时不表），可以求出最优解</li></ul><p>举个例子：</p><p>场景设定：<br> 您要去菜市场买菜，家里锅只能煮最多10斤菜，您带了一个“布兜”，最多也只能装10斤。</p><p>市场里<strong>只有这么多重量</strong>的食材：</p><table><thead><tr><th>菜名</th><th>重量（斤）</th><th>美味度（分）</th></tr></thead><tbody><tr><td>西红柿</td><td>2斤</td><td>3分</td></tr><tr><td>土豆</td><td>3斤</td><td>4分</td></tr><tr><td>鸡蛋</td><td>4斤</td><td>5分</td></tr><tr><td>牛肉</td><td>5斤</td><td>8分</td></tr></tbody></table><p>一种常见的满足直觉的算法是，我先买<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>性价比</mtext><mo>=</mo><mtext>美味度</mtext><mi mathvariant="normal">/</mi><mtext>重量</mtext></mrow><annotation encoding="application/x-tex">性价比=美味度/重量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">性价比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">美味度</span><span class="mord">/</span><span class="mord cjk_fallback">重量</span></span></span></span>最高的食材，以此类推。分别是牛肉（1.6），西红柿（1.5），土豆（1.33），鸡蛋（1.25）。<br> 10斤可以得15分美味度。这个就是最优解。然后把限制改到9斤时，这个算法，只能买牛肉+西红柿（9分），错过了牛肉+鸡蛋（13分）的最优解。<strong>这个算法就叫贪心算法</strong></p><h2 id="动态规划" tabindex="-1"><a class="header-anchor" href="#动态规划"><span>动态规划</span></a></h2><p><strong>runner2011</strong>:<br> 简单说动态规划是把大问题拆解成子问题，求得子问题的最优解，从而得到大问题最优解。也是一种<strong>递归</strong>的思想。<br> 换句话说，</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>R</mi><mi>t</mi></msub><mo>+</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">R_{t+1}=R_t + r </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></span></p><p>只要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">R_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是最优解，r是t+1这一步最优解，那<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>就是最优解（最大值）。这个就是<a href="https://en.wikipedia.org/wiki/Bellman_equation" target="_blank" rel="noopener noreferrer">贝尔曼方程</a>和动态规划的思想。Richard E. Bellman是二者发明人。<br> 强化学习MDP(有限马尔可夫决策过程)最大化价值函数也是用这一方法。</p><p>一、列举所有可行组合（≤10斤）</p><p>把所有可能组合算一遍更直观：</p><table><thead><tr><th>组合</th><th>总重量</th><th>总美味度</th></tr></thead><tbody><tr><td>西红柿</td><td>2</td><td>3</td></tr><tr><td>土豆</td><td>3</td><td>4</td></tr><tr><td>鸡蛋</td><td>4</td><td>5</td></tr><tr><td>牛肉</td><td>5</td><td>8</td></tr><tr><td>西红柿+土豆</td><td>5</td><td>7</td></tr><tr><td>西红柿+鸡蛋</td><td>6</td><td>8</td></tr><tr><td>西红柿+牛肉</td><td>7</td><td>11</td></tr><tr><td>土豆+鸡蛋</td><td>7</td><td>9</td></tr><tr><td>土豆+牛肉</td><td>8</td><td>12</td></tr><tr><td>鸡蛋+牛肉</td><td>9</td><td>13</td></tr><tr><td>西红柿+土豆+鸡蛋</td><td>9</td><td>12</td></tr><tr><td>西红柿+土豆+牛肉</td><td>10</td><td>15 ←最大</td></tr><tr><td>西红柿+鸡蛋+牛肉</td><td>11</td><td>超重</td></tr><tr><td>土豆+鸡蛋+牛肉</td><td>12</td><td>超重</td></tr><tr><td>全部</td><td>14</td><td>超重</td></tr></tbody></table><p>最优解：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>西红柿 + 土豆 + 牛肉</span></span>\n<span class="line"><span>重量 = 2+3+5 = 10</span></span>\n<span class="line"><span>美味度 = 3+4+8 = 15</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最优解重量是：5+3+2。 8+2和7+3拆解成最小子问题后都是5+3+2. 而6+4继续拆成4+2+2，在0-1背包问题（物品只能选一次）不合法，5+5同样不合法。<br> 前面提到，因为拆解成了最优子问题，而每个子问题只要是最优解，最后总问题就是最优解。</p><p><strong>题外话</strong>：</p><blockquote><p>动态规划也可以求最短路径，那和Dijkstra算法有什么区别？<br> 大概区别（不一定对）：</p><ul><li>动态规划适用于DAG（有向无环图），Dijkstra无此要求</li><li>限制在 DAG 中，DP 最短路径和 Dijkstra 的状态转移完全一致，但DP 使用拓扑顺序，Dijkstra 使用贪心顺序，算法思想仍不同。</li></ul></blockquote><h2 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h2><table><thead><tr><th style="text-align:left;">维度</th><th style="text-align:left;">贪心算法</th><th style="text-align:left;">动态规划</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>时间效率</strong></td><td style="text-align:left;">快（<code>O(amount)</code>）</td><td style="text-align:left;">慢（<code>O(amount × coin_types)</code>）</td></tr><tr><td style="text-align:left;"><strong>空间效率</strong></td><td style="text-align:left;">低（<code>O(1)</code>）</td><td style="text-align:left;">高（<code>O(amount)</code>）</td></tr><tr><td style="text-align:left;"><strong>解的质量</strong></td><td style="text-align:left;">可能非最优（如 <code>4,1,1</code>）</td><td style="text-align:left;">保证最优（如 <code>3,3</code>）</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">问题满足贪心性质时</td><td style="text-align:left;">通用性强，但需要更多计算</td></tr></tbody></table>',22))])}]]),p=JSON.parse('{"path":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"贪心算法，动态规划","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"贪心算法，动态规划 贪心算法：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。 动态规划：像一群人分头探索所有路径，最后汇总最优路线 动态规划：计算每一个子问题，并记录子问题的结果。核心：子问题只算一遍。 这个方式来降复杂度，而通常不能拆分成可复用的子问题，导致复杂度太高 贪心算法：每次取最解决的结果，一条路走到黑 贪心算法的问题 是一种快速接近最...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贪心算法，动态规划\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-15T14:51:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"贪心算法，动态规划"}],["meta",{"property":"og:description","content":"贪心算法，动态规划 贪心算法：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。 动态规划：像一群人分头探索所有路径，最后汇总最优路线 动态规划：计算每一个子问题，并记录子问题的结果。核心：子问题只算一遍。 这个方式来降复杂度，而通常不能拆分成可复用的子问题，导致复杂度太高 贪心算法：每次取最解决的结果，一条路走到黑 贪心算法的问题 是一种快速接近最..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-15T14:51:25.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2026-02-15T14:51:25.000Z"}]]},"git":{"createdTime":1749351682000,"updatedTime":1771167085000,"contributors":[{"name":"Runner2011","username":"Runner2011","email":"chenjfsea@gmail.com","commits":2,"url":"https://github.com/Runner2011"},{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":3.28,"words":983},"filePathRelative":"posts/计算机基础/数据结构算法/贪心算法，动态规划.md","excerpt":"\\n<ul>\\n<li><strong>贪心算法</strong>：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。</li>\\n<li><strong>动态规划</strong>：像一群人分头探索所有路径，最后汇总最优路线</li>\\n</ul>\\n<p>动态规划：计算每一个子问题，并记录子问题的结果。<strong>核心：子问题只算一遍。</strong> 这个方式来降复杂度，而<a href=\\"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html\\" target=\\"_blank\\">NP问题</a>通常不能拆分成<strong>可复用的子问题</strong>，导致复杂度太高</p>","autoDesc":true}')}}]);