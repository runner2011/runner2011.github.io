"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[1438],{628:(t,n)=>{n.A=(t,n)=>{const r=t.__vccOpts||t;for(const[t,o]of n)r[t]=o;return r}},3354:(t,n,r)=>{r.r(n),r.d(n,{comp:()=>s,data:()=>a});var o=r(8178);const e={},s=(0,r(628).A)(e,[["render",function(t,n){return(0,o.uX)(),(0,o.CE)("div",null,n[0]||(n[0]=[(0,o.Fv)('<h1 id="浮点计数法" tabindex="-1"><a class="header-anchor" href="#浮点计数法"><span>浮点计数法</span></a></h1><h2 id="为什么2-1-2-2-2-3-2-n之和的方式-可以-近似-表示任何尾数-原因是什么" tabindex="-1"><a class="header-anchor" href="#为什么2-1-2-2-2-3-2-n之和的方式-可以-近似-表示任何尾数-原因是什么"><span>为什么2^-1, 2^-2, 2^-3 ... 2^-n之和的方式，可以‘近似’表示任何尾数，原因是什么</span></a></h2><blockquote><p>浮点数最终存储的值：存储的二进制尾数代表的值其实是：$$0.5 + 0.25 + 0.125 + 0.0625 + \\dots$$</p></blockquote><p>这是一个极其深刻的数学问题，触及了<strong>数制系统的本质</strong>。</p><p>之所以 的组合可以“近似”表示任何小数，是因为这种方式本质上是一个 <strong>“二分逼近” (Binary Approximation)</strong> 的过程。</p><p>你可以把它想象成<strong>用一把只有“对半切”功能的刀，去切一块长度为 1 的蛋糕，试图切出你想要的任意长度。</strong></p><p>以下是三个维度的解释：直观逻辑、几何原理和数学极限。</p><hr><h3 id="_1-直观类比-天平与砝码" tabindex="-1"><a class="header-anchor" href="#_1-直观类比-天平与砝码"><span>1. 直观类比：天平与砝码</span></a></h3><p>想象你有一个天平，左边放着你想要表示的任意重量（比如 0.7 吨）。<br> 你的右边只有一套特殊的<strong>砝码</strong>，重量分别是：</p><ul><li>(0.5)</li><li>(0.25)</li><li>(0.125)</li><li>(0.0625)</li><li>...以此类推，每个都是前一个的一半。</li></ul><p><strong>操作逻辑（贪心算法）：</strong></p><ol><li><strong>放 0.5 的砝码</strong>：如果总重没超，就留着（记为 1）；如果超了，就拿掉（记为 0）。</li><li><strong>放 0.25 的砝码</strong>：在剩下的基础上，再放 0.25，没超就留着，超了拿掉。</li><li><strong>重复下去</strong>...</li></ol><p>只要你的砝码分得足够细（ 足够大），你就可以把右边的总重量调整到<strong>无限接近</strong>左边的任意重量。</p><ul><li><strong>FP16 的局限</strong>：FP16 只有 10 个这样的砝码（10位尾数）。用这 10 个砝码凑不出来的重量，就只能“四舍五入”了，这就是<strong>精度丢失</strong>。</li></ul><hr><h3 id="_2-几何解释-数轴切割" tabindex="-1"><a class="header-anchor" href="#_2-几何解释-数轴切割"><span>2. 几何解释：数轴切割</span></a></h3><p>这实际上是对 区间进行不断的<strong>区间二分</strong>。</p><ul><li><strong>第 1 刀 ()</strong>：把 0 到 1 分成两半，刻度是 0.5。你现在能表示 {0, 0.5, 1}。</li><li><strong>第 2 刀 ()</strong>：把剩下的每段再分两半，增加刻度 0.25, 0.75。现在能精确表示 {0, 0.25, 0.5, 0.75, 1}。</li><li><strong>第 3 刀 ()</strong>：增加 0.125, 0.375...</li></ul><p><strong>原因核心：</strong><br> 随着 的增加，两个刻度之间的<strong>间隙 (Gap)</strong> 会以 的速度迅速缩小。</p><ul><li>当 (FP16) 时，间隙是 。</li><li>当 (FP32) 时，间隙是 。</li></ul><p><strong>虽然间隙永远存在（除非 无穷大），但在有限的精度要求下，这个间隙小到可以忽略不计，这就是“近似”的含义。</strong></p><hr><h3 id="_3-数学原理-级数与完备性" tabindex="-1"><a class="header-anchor" href="#_3-数学原理-级数与完备性"><span>3. 数学原理：级数与完备性</span></a></h3><p>从数学上讲，这利用了<strong>几何级数 (Geometric Series)</strong> 的性质。</p><p>我们知道：</p><p>这意味着，如果你被允许使用无限多个位，你可以填满 0 到 1 之间的<strong>所有空间</strong>。</p><p>对于任意实数 ，我们总能找到一个二进制序列 （其中 为 0 或 1），使得：</p><p><strong>为什么有些数是“无限循环”的？</strong><br> 这就好比在十进制里，用 去凑 。</p><ul><li></li><li>因为 3 不能整除 10 的因子（2和5）。</li></ul><p>同理，在二进制里，如果一个分数的<strong>分母</strong>包含除了 2 以外的质因子（比如 0.1 的分数是 ，分母含有 5），那么它在二进制里就一定是<strong>无限循环小数</strong>。<br> 因为你永远无法用有限个“2的幂次之和”精确凑出它，只能无限逼近。</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>这种表示法之所以有效，是因为<strong>2的幂次级数收敛</strong>，且随着幂次降低，其覆盖网格的密度呈指数级增加。</p><ul><li><strong>对于计算机</strong>：它只需要判断“要不要加这个权重”（0或1），这是电路最喜欢的开关操作。</li><li><strong>对于数学</strong>：它保证了只要位数足够多，误差可以小到任意给定的 范围内。</li></ul>',34)]))}]]),a=JSON.parse('{"path":"/posts/Math/%E6%B5%AE%E7%82%B9%E8%AE%A1%E6%95%B0%E6%B3%95.html","title":"浮点计数法","lang":"zh-CN","frontmatter":{"date":"2026-01-22T00:00:00.000Z","tag":["Math","AI_GEN"],"description":"浮点计数法 为什么2^-1, 2^-2, 2^-3 ... 2^-n之和的方式，可以‘近似’表示任何尾数，原因是什么 浮点数最终存储的值：存储的二进制尾数代表的值其实是：$$0.5 + 0.25 + 0.125 + 0.0625 + \\\\dots$$ 这是一个极其深刻的数学问题，触及了数制系统的本质。 之所以 的组合可以“近似”表示任何小数，是因为这种方...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"浮点计数法\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-01-22T00:00:00.000Z\\",\\"dateModified\\":\\"2026-01-23T08:24:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/Math/%E6%B5%AE%E7%82%B9%E8%AE%A1%E6%95%B0%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"浮点计数法"}],["meta",{"property":"og:description","content":"浮点计数法 为什么2^-1, 2^-2, 2^-3 ... 2^-n之和的方式，可以‘近似’表示任何尾数，原因是什么 浮点数最终存储的值：存储的二进制尾数代表的值其实是：$$0.5 + 0.25 + 0.125 + 0.0625 + \\\\dots$$ 这是一个极其深刻的数学问题，触及了数制系统的本质。 之所以 的组合可以“近似”表示任何小数，是因为这种方..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-01-23T08:24:45.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:tag","content":"Math"}],["meta",{"property":"article:published_time","content":"2026-01-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-01-23T08:24:45.000Z"}]]},"git":{"createdTime":1769156685000,"updatedTime":1769156685000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":3.06,"words":918},"filePathRelative":"posts/Math/浮点计数法.md","excerpt":"\\n<h2>为什么2^-1, 2^-2, 2^-3 ... 2^-n之和的方式，可以‘近似’表示任何尾数，原因是什么</h2>\\n<blockquote>\\n<p>浮点数最终存储的值：存储的二进制尾数代表的值其实是：$$0.5 + 0.25 + 0.125 + 0.0625 + \\\\dots$$</p>\\n</blockquote>\\n<p>这是一个极其深刻的数学问题，触及了<strong>数制系统的本质</strong>。</p>\\n<p>之所以  的组合可以“近似”表示任何小数，是因为这种方式本质上是一个 <strong>“二分逼近” (Binary Approximation)</strong> 的过程。</p>","autoDesc":true}')}}]);