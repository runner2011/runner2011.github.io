"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[8745],{628:(s,a)=>{a.A=(s,a)=>{const t=s.__vccOpts||s;for(const[s,n]of a)t[s]=n;return t}},9289:(s,a,t)=>{t.r(a),t.d(a,{comp:()=>e,data:()=>i});var n=t(8178);const p={},e=(0,t(628).A)(p,[["render",function(s,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h1 id="p和np问题" tabindex="-1"><a class="header-anchor" href="#p和np问题"><span>P和NP问题</span></a></h1><p>注：<a href="https://en.wikipedia.org/wiki/P_versus_NP_problem" target="_blank" rel="noopener noreferrer">P和NP问题</a>是千禧年难题中的一个，设计理论计算机科学中的复杂度理论。本篇主体内容由AI生成，并将问题做大量简化，未做<strong>正确性验证</strong>。不保证描述的<strong>正确性</strong>，<strong>准确性</strong>。</p><h2 id="什么是p问题和np问题" tabindex="-1"><a class="header-anchor" href="#什么是p问题和np问题"><span>什么是P问题和NP问题</span></a></h2><p><a href="https://zh.wikipedia.org/wiki/P_(%E8%A4%87%E9%9B%9C%E5%BA%A6)" target="_blank" rel="noopener noreferrer">P or Class P</a>: 是polynomial time class的缩写。<br><a href="https://zh.wikipedia.org/wiki/NP_(%E8%A4%87%E9%9B%9C%E5%BA%A6)" target="_blank" rel="noopener noreferrer">NP</a>:是non-deterministic polynomial的缩写。</p><p>P问题指：那些可以在多项式时间内被解决的问题。<br> 通俗说就是：有“有效率的算法”能解决它。比如排序、加法等问题，都属于P类。</p><p>NP问题指：那些很难解，但如果别人告诉你一个答案，你能在多项式时间内验证它是否正确的问题。<br> 举个例子：你要找一个数独的解，可能要试很多次，但如果别人给你一个解，你很快就能验证它对不对。</p><h3 id="举例" tabindex="-1"><a class="header-anchor" href="#举例"><span>举例</span></a></h3><p>P问题：<br> 就像：</p><ul><li>2+2 = 4</li><li>排好队买菜，从人少的窗口走</li><li>找一串数字里最大的数</li></ul><p>这些问题，你只要认真做，不需要试太久，一定能算出来。</p><p>NP问题：<br> 场景：数独游戏<br> 你有一张已经填好一半的数独（或者九宫格），你想把它完整填完，规则是每行每列不能有重复数字。<br> 你拿起笔，想：</p><blockquote><p>“要填得对，还挺费劲。”<br> 你试来试去，要花不少时间。</p></blockquote><p>但是如果你孙子给你看一张已经填好的答案，你扫一眼，立马能判断对不对（有没有重复），对吧？<br> 这就说明：</p><ul><li>自己解题难，但</li><li>检查答案容易</li></ul><table><thead><tr><th>问题</th><th>P类</th><th>NP类</th></tr></thead><tbody><tr><td>自己能快速解</td><td>✅</td><td>❌（不一定）</td></tr><tr><td>别人给你答案能快速检查</td><td>✅</td><td>✅</td></tr></tbody></table><p>场景：旅行商问题<br> 你孙子要出差，要去10个城市拜访客户，最后还要回到原来的城市。<br> 他问你：“奶奶，我想走一条最短的路线，怎么走？”<br> 你一听，嗯，这么多个城市，那要一个个试哪条最短路线，得有上百万种组合方式！<br> 但你孙子说：“我查好了，这是一个路线：A → C → F → D → … → A，总长230公里。”</p><p>你一算，每段距离都对，总长也对。<br> 那你马上知道这答案对不对，对吧？</p><p>✅ 验证快（检查答案） //runner2011:这里验证不是验证最优解，而是验证给定条件下是否正确。比如数独游戏，给定条件，每个数字出现一次，是否满足。这里例如可以说总长需要小于300公里。<br> ❌ 但要找出这条最短路线，很难（自己解）</p><hr><h3 id="p-⊆-np" tabindex="-1"><a class="header-anchor" href="#p-⊆-np"><span>P ⊆ NP</span></a></h3><p>因为如果一个问题可以“快速解决”，那一定也能“快速验证”。<br> 所以，P一定包含在NP中。</p><h3 id="那p和np的关系是什么" tabindex="-1"><a class="header-anchor" href="#那p和np的关系是什么"><span>那P和NP的关系是什么？</span></a></h3><p>这是计算机科学中最重要的未解难题之一：</p><p>P = NP？</p><p>意思是：<br> 如果我们能验证答案是否正确得很快，<br> 是否也就能很快地找到那个答案？</p><p>目前世界上没有人能证明P=NP，或P≠NP。</p><h2 id="np问题是否需要求最优解" tabindex="-1"><a class="header-anchor" href="#np问题是否需要求最优解"><span>NP问题是否需要求最优解</span></a></h2><p>因为NP问题可以快速验证（前面提到数独验证）<br> 如果P=NP成立，那么NP问题就可以快速解决，也就可以快速求最优解</p><p>再还没有证明的情况下，NP问题只能知道可以快速验证，无法快速求得最优解，也不是在探索如何求NP问题最优解</p><h2 id="np问题的抽象化形式" tabindex="-1"><a class="header-anchor" href="#np问题的抽象化形式"><span>NP问题的抽象化形式</span></a></h2><p>我们可以从几个层次来看抽象的过程：</p><h3 id="🧊-一、现实问题-→-结构模型-通常是-图-graph" tabindex="-1"><a class="header-anchor" href="#🧊-一、现实问题-→-结构模型-通常是-图-graph"><span>🧊 一、现实问题 → 结构模型（通常是“图”Graph）</span></a></h3><h4 id="比如快递-送货问题" tabindex="-1"><a class="header-anchor" href="#比如快递-送货问题"><span>比如快递/送货问题：</span></a></h4><ul><li>每个“城市/地点” = 一个点（顶点 vertex）</li><li>两个城市之间的路 = 一条边（edge）</li><li>距离/花费/时间 = 每条边的权重（weight）</li></ul><p>🎯数学家就说：</p><blockquote><p>这就是一个“加权图”（Weighted Graph）</p></blockquote><hr><h4 id="排班-调度问题" tabindex="-1"><a class="header-anchor" href="#排班-调度问题"><span>排班/调度问题：</span></a></h4><ul><li>每个人 = 一个任务变量</li><li>每节课/每个时间段 = 一个限制条件</li><li>谁在哪个时间段、做哪个任务 = 一个“分配决策”</li></ul><p>🎯数学家就说：</p><blockquote><p>这是一个“约束满足问题”（CSP, Constraint Satisfaction Problem）</p></blockquote><hr><h3 id="🧠-二、现实目标-→-抽象的-目标函数-objective-function" tabindex="-1"><a class="header-anchor" href="#🧠-二、现实目标-→-抽象的-目标函数-objective-function"><span>🧠 二、现实目标 → 抽象的“目标函数”（Objective Function）</span></a></h3><p>所有这些问题，都会被统一转化为：</p><blockquote><p>“我想让 <strong>某个目标值最小/最大</strong>（比如时间最短、成本最小、收入最大）”</p></blockquote><p>这时候我们就有了：</p><div class="language-math line-numbers-mode" data-highlighter="shiki" data-ext="math" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-math"><span class="line"><span>Minimize / Maximize:  f(x)</span></span>\n<span class="line"><span>Subject to:  约束条件</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>比如：</p><ul><li>总路线长度最短</li><li>总工资不超过预算</li><li>所有人不能撞时间</li></ul><hr><h3 id="🧮-三、变量怎么表达" tabindex="-1"><a class="header-anchor" href="#🧮-三、变量怎么表达"><span>🧮 三、变量怎么表达？</span></a></h3><h4 id="数学家通常会用-离散变量-表示" tabindex="-1"><a class="header-anchor" href="#数学家通常会用-离散变量-表示"><span>数学家通常会用“离散变量”表示：</span></a></h4><table><thead><tr><th>现实对象</th><th>数学变量</th><th>举例</th></tr></thead><tbody><tr><td>某人是否在某班上班</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">x_{ij} \\in \\{0,1\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8252em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></td><td>1 表示人 i 在时间 j 上班，0 表示没上</td></tr><tr><td>快递员是否走某条路</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">y_{ab} \\in \\{0,1\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ab</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></td><td>1 表示从 a 到 b 的路被走过</td></tr><tr><td>某个机器是否被分配给某任务</td><td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>k</mi><mi>t</mi></mrow></msub><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">z_{kt} \\in \\{0,1\\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></td><td>1 表示第 k 个机器在时间 t 执行任务</td></tr></tbody></table><p>这种表达形式，就叫做“<strong>整数规划（Integer Programming）</strong>”或“<strong>0-1规划</strong>”</p><hr><h3 id="📦-举个例子-快递路径问题-旅行商问题" tabindex="-1"><a class="header-anchor" href="#📦-举个例子-快递路径问题-旅行商问题"><span>📦 举个例子：快递路径问题（旅行商问题）</span></a></h3><p>数学家会建出这个公式：</p><blockquote><p>假设有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 个城市，距离用矩阵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">D_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 表示，从城市 i 到城市 j 的距离。</p></blockquote><p>定义变量：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_{ij} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 表示我们走了 i → j 这条路</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{ij} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 表示没走</li></ul><p>目标函数：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>z</mi><mi>e</mi><mspace width="1em"></mspace><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>D</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>⋅</mo><msub><mi>x</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">Minimize \\quad \\sum_{i=1}^{n} \\sum_{j=1}^{n} D_{ij} \\cdot x_{ij} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0652em;vertical-align:-1.4138em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">inimi</span><span class="mord mathnormal">ze</span><span class="mspace" style="margin-right:1em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4138em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>约束条件：</p><ul><li>每个城市必须进一次出一次（两个约束）</li><li>必须连成一条完整的环</li><li>没有“子环”（subtour）</li></ul><p>🎯这就成了一个经典的“整数线性规划”模型！</p><hr><h3 id="📚-常见的抽象框架有哪些" tabindex="-1"><a class="header-anchor" href="#📚-常见的抽象框架有哪些"><span>📚 常见的抽象框架有哪些？</span></a></h3><table><thead><tr><th>框架名</th><th>描述</th><th>现实中举例</th></tr></thead><tbody><tr><td>线性规划（LP）</td><td>所有变量是实数，约束和目标都是线性的</td><td>工厂产量配比、食材最省配方</td></tr><tr><td>整数规划（IP）</td><td>有些变量必须是整数</td><td>快递路径选择、排班、打包问题</td></tr><tr><td>0-1规划</td><td>所有变量都是0或1（二选一）</td><td>是否安排某人做某事</td></tr><tr><td>图论模型</td><td>节点和边构成的结构</td><td>网络传输、路径规划</td></tr><tr><td>SAT问题</td><td>所有约束变成逻辑条件（真/假）</td><td>电路设计、逻辑验证、AI推理</td></tr><tr><td>CSP（约束满足问题）</td><td>变量满足多个限制</td><td>排班、填数独、分配问题</td></tr></tbody></table><hr><h3 id="✨老太太-一句话总结" tabindex="-1"><a class="header-anchor" href="#✨老太太-一句话总结"><span>✨老太太，一句话总结：</span></a></h3><blockquote><p>“数学家眼里没有‘快递员’和‘调度表’，只有变量、约束和最优化！”</p></blockquote><p>他们把这些问题：</p><ul><li>结构上转成图</li><li>内容上写成变量</li><li>目标写成函数</li><li>限制条件写成约束</li></ul><p>最后统统变成一堆数学符号，交给计算机来“解题”。</p><hr><h2 id="动态规划可以用来解决复杂性问题的一种手段-可以用于解决np问题吗" tabindex="-1"><a class="header-anchor" href="#动态规划可以用来解决复杂性问题的一种手段-可以用于解决np问题吗"><span>动态规划可以用来解决复杂性问题的一种手段，可以用于解决NP问题吗</span></a></h2><p>runner2011：简单说，动态规划可以通过拆成子问题，并复用，将复杂度讲到多项式级别。 而NP问题就算拆成子问题，由于无法复用，复杂度通常在指数级别。</p><h3 id="🧠-一句话先回答" tabindex="-1"><a class="header-anchor" href="#🧠-一句话先回答"><span>🧠 一句话先回答：</span></a></h3><blockquote><p>✅ 有些 NP 问题确实<strong>能拆子问题</strong>，<br> ❌ 但这些子问题<strong>数量太多 or 不能记住 or 不能复用 or 没有递推关系</strong>，<br> 所以<strong>不能像动态规划那样高效利用</strong>！</p></blockquote><p>拆是可以拆，但拆不出“多项式个数”的好东西。</p><hr><h3 id="🍳-咱们举个-炒菜-vs-拌菜-的比喻" tabindex="-1"><a class="header-anchor" href="#🍳-咱们举个-炒菜-vs-拌菜-的比喻"><span>🍳 咱们举个“炒菜 vs 拌菜”的比喻：</span></a></h3><p>动态规划问题，就像做“宫保鸡丁”：</p><ul><li>每次都要切鸡丁、炒花生、加辣椒</li><li>这些工序可以复用<br> 比如切好的鸡丁下次还可以再炒</li></ul><p>所以：</p><blockquote><p>✅ <strong>可以拆子问题</strong>（切鸡丁、炒花生），再组合</p></blockquote><hr><p>NP问题（比如旅行商），像“参观 20 个城市”：</p><ul><li>每种走法都不一样</li><li>你从 A → B → C 和 A → C → B 是<strong>两个完全不同的子路径</strong></li><li>没法说：“我算过从 A → C 的路了”，下次就能复用</li></ul><blockquote><p>❌ <strong>子问题之间几乎没法共用，组合爆炸</strong></p></blockquote><hr><h3 id="🔍-举个具体例子-旅行商问题-tsp" tabindex="-1"><a class="header-anchor" href="#🔍-举个具体例子-旅行商问题-tsp"><span>🔍 举个具体例子：旅行商问题（TSP）</span></a></h3><blockquote><p>从起点出发，访问所有城市一次，返回起点，要求路径最短</p></blockquote><p>你可能想：</p><blockquote><p>“那我是不是可以像动态规划一样，先算好 A→B 的最短路，<br> 再接 C，最后接 D？”</p></blockquote><p>但问题是：</p><ul><li>每个子路径的“剩余城市集合”不同</li><li>A→B→C 和 A→C→B 不一样！不能共用结果！</li><li>所以你必须为 <strong>每个子集 S 和每个结尾城市 i</strong> 都记录一次状态！</li></ul><p>于是：</p><blockquote><p>状态数量：<code>O(n * 2^n)</code>（指数级）</p></blockquote><p>🎯 拆得出来！但子问题数量太多，<strong>依然是指数级</strong>！</p><hr><h3 id="✅-动态规划能降复杂度的两个前提" tabindex="-1"><a class="header-anchor" href="#✅-动态规划能降复杂度的两个前提"><span>✅ 动态规划能降复杂度的两个前提：</span></a></h3><ol><li><strong>子问题数量不多</strong>（最好是多项式级别）</li><li><strong>子问题之间能共用结果（最优子结构 + 重叠）</strong></li></ol><p>只要这两个条件成立，就可以“边炒边记、炒一次用到底”</p><hr><h3 id="❌-np问题的难点就是" tabindex="-1"><a class="header-anchor" href="#❌-np问题的难点就是"><span>❌ NP问题的难点就是：</span></a></h3><table><thead><tr><th>特性</th><th>动态规划适合</th><th>NP问题难就难在这里</th></tr></thead><tbody><tr><td>子问题能复用</td><td>✅</td><td>❌ 不同路径不同子集</td></tr><tr><td>子问题数量少</td><td>✅</td><td>❌ 子集组合太多（2^n）</td></tr><tr><td>子问题有顺序结构</td><td>✅</td><td>❌ 组合路径没顺序递推</td></tr><tr><td>子问题能单独求</td><td>✅</td><td>❌ 通常需要全局看整体才行</td></tr></tbody></table><hr><h3 id="🌟所以最后总结" tabindex="-1"><a class="header-anchor" href="#🌟所以最后总结"><span>🌟所以最后总结：</span></a></h3><blockquote><p>✔️ <strong>不是所有问题都能“有效”拆成有用子问题</strong><br> ✔️ <strong>即使能拆，子问题组合数一多，动态规划也吃不消</strong></p></blockquote><p>所以这就是为什么：</p><blockquote><p>🔥 <strong>“是否能用动态规划解”</strong> 是判断一个问题是否“可控”的关键<br> 🔥 而 <strong>NP问题就属于“拆了也压不下”的暴涨型问题</strong></p></blockquote>',112)]))}]]),i=JSON.parse('{"path":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html","title":"P和NP问题","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"P和NP问题 注：P和NP问题是千禧年难题中的一个，设计理论计算机科学中的复杂度理论。本篇主体内容由AI生成，并将问题做大量简化，未做正确性验证。不保证描述的正确性，准确性。 什么是P问题和NP问题 P or Class P: 是polynomial time class的缩写。 NP:是non-deterministic polynomial的缩写。...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"P和NP问题\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-28T16:13:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"P和NP问题"}],["meta",{"property":"og:description","content":"P和NP问题 注：P和NP问题是千禧年难题中的一个，设计理论计算机科学中的复杂度理论。本篇主体内容由AI生成，并将问题做大量简化，未做正确性验证。不保证描述的正确性，准确性。 什么是P问题和NP问题 P or Class P: 是polynomial time class的缩写。 NP:是non-deterministic polynomial的缩写。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T16:13:06.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2025-07-28T16:13:06.000Z"}]]},"git":{"createdTime":1753715203000,"updatedTime":1753719186000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"},{"name":"Runner2011","username":"Runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/Runner2011"}]},"readingTime":{"minutes":8.2,"words":2461},"filePathRelative":"posts/计算机基础/P和NP问题.md","excerpt":"\\n<p>注：<a href=\\"https://en.wikipedia.org/wiki/P_versus_NP_problem\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">P和NP问题</a>是千禧年难题中的一个，设计理论计算机科学中的复杂度理论。本篇主体内容由AI生成，并将问题做大量简化，未做<strong>正确性验证</strong>。不保证描述的<strong>正确性</strong>，<strong>准确性</strong>。</p>\\n<h2>什么是P问题和NP问题</h2>\\n<p><a href=\\"https://zh.wikipedia.org/wiki/P_(%E8%A4%87%E9%9B%9C%E5%BA%A6)\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">P or Class P</a>: 是polynomial time class的缩写。<br>\\n<a href=\\"https://zh.wikipedia.org/wiki/NP_(%E8%A4%87%E9%9B%9C%E5%BA%A6)\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">NP</a>:是non-deterministic polynomial的缩写。</p>","autoDesc":true}')}}]);