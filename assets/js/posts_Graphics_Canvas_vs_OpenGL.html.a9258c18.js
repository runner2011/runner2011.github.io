"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[8792],{628:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,r]of t)a[e]=r;return a}},6867:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>i,data:()=>s});var r=a(8178);const n={},i=(0,a(628).A)(n,[["render",function(e,t){return(0,r.uX)(),(0,r.CE)("div",null,t[0]||(t[0]=[(0,r.Fv)('<h1 id="绘制两个rect相反方向旋转为什么要调用canvas-save" tabindex="-1"><a class="header-anchor" href="#绘制两个rect相反方向旋转为什么要调用canvas-save"><span>绘制两个rect相反方向旋转为什么要调用canvas save</span></a></h1><h2 id="code" tabindex="-1"><a class="header-anchor" href="#code"><span>Code</span></a></h2><p>╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮<br> │ ✓ Edit gemini_ver_mod.html: // 画一些旋转的粒子或线条... =&gt; // 画一些旋转的粒子或线条... │<br> │ │<br> │ 96 angle += 30 / (radius + 10); │<br> │ 97 const a = 2; //6 │<br> │ 98 for (let i = 0; i &lt; a; i++) { │<br> │ 99 - canvasCtx.rotate(angle + (i * Math.PI / 3)); │<br> │ 99 + canvasCtx.save(); │<br> │ 100 + const direction = (i === 0) ? 1 : -1; │<br> │ 101 + canvasCtx.rotate(direction * angle + (i * Math.PI / 4)); // Offset of 45 deg │<br> │ 102 canvasCtx.strokeRect(-radius/2, -radius/2, radius, radius); │<br> │ 103 + canvasCtx.restore(); │<br> │ 104 } │<br> │ 105 │<br> │ 106 // 画粒子点 │<br> ╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯<br> ✦ The two rectangles now rotate in opposite directions (one clockwise, one counter-clockwise) with a slight<br> initial offset.</p><h2 id="canvasctx-save-什么意思" tabindex="-1"><a class="header-anchor" href="#canvasctx-save-什么意思"><span>canvasCtx.save()什么意思</span></a></h2><p>✦ canvasCtx.save() 是 HTML5 Canvas API 中的一个方法，它的作用是 保存当前画布的所有状态。</p><p>想象 Canvas 的状态就像是一个游戏存档。当你调用 save()<br> 时，浏览器会把当前的“画笔设置”和“坐标系状态”拍一张快照，存进一个栈（Stack）里。</p><p>它保存了什么？</p><ol><li>变换矩阵 (Transformation Matrix)： 包括 translate (平移), rotate (旋转), scale<br> (缩放)。这是最重要的，也是我刚才用它的原因。</li><li>样式属性： strokeStyle (线条颜色), fillStyle (填充颜色), lineWidth (线宽), shadowBlur (阴影) 等等。</li><li>裁剪区域 (Clipping Region)。</li></ol><p>为什么要用它？<br> 在刚才的代码中：</p><p>1 for (let i = 0; i &lt; a; i++) {<br> 2 canvasCtx.save(); // 1. 存档：记住现在的状态（中心点未旋转的状态）<br> 3<br> 4 const direction = (i === 0) ? 1 : -1;<br> 5 canvasCtx.rotate(direction * angle + ...); // 2. 旋转坐标系<br> 6 canvasCtx.strokeRect(...); // 3. 画矩形<br> 7<br> 8 canvasCtx.restore(); // 4. 读档：恢复到第1步的状态<br> 9 }</p><p>如果不使用 save() 和 restore()，Canvas 的状态是累加的。</p><ul><li>没有 save/restore： 第一个矩形旋转了 30 度，第二个矩形如果想反向转 30<br> 度，它实际上是在第一个矩形的基础上转的，结果会乱套。</li><li>有 save/restore： 每次画矩形前都从“干净”的状态开始，画完后立刻恢复，互不干扰。</li></ul><h2 id="似乎用opengl-api绘制多个rect的transform并不需要做这个" tabindex="-1"><a class="header-anchor" href="#似乎用opengl-api绘制多个rect的transform并不需要做这个"><span>似乎用opengl api绘制多个rect的transform并不需要做这个？</span></a></h2><p>✦ 你说得很对！你的直觉非常敏锐。</p><p>这主要取决于你指的是 现代 OpenGL (Modern OpenGL / Programmable Pipeline) 还是 旧版 OpenGL (Legacy / Fixed<br> Function)。</p><ol><li>现代 OpenGL (Shader 时代)<br> 确实不需要像 Canvas 这样 <code>save/restore</code>。</li></ol><p>在现代图形编程（OpenGL 3.0+, Vulkan, DirectX, WebGL）中，绘制逻辑通常是这样的：</p><ul><li>独立的矩阵计算：你在 CPU 端（代码里）为每一个物体单独计算一个 模型矩阵 (Model Matrix)。 <ul><li>矩形 A 的矩阵 = 平移(x,y) * 旋转(30度) * 缩放(1,1)</li><li>矩形 B 的矩阵 = 平移(x,y) * 旋转(-30度) * 缩放(1,1)</li></ul></li><li>传递给 GPU：当你画矩形 A 时，把 矩阵 A 传给 Shader；画矩形 B 时，把 矩阵 B 传给 Shader。</li><li>无状态干扰：GPU 在画矩形 B 时，根本不知道刚才画矩形 A 用了什么矩阵。它们是完全独立的绘制指令 (Draw<br> Call)。</li></ul><p>Canvas 2D 的设计逻辑比较像一个“状态机”。它只有一个全局的“画笔/坐标系”。如果你把坐标系转了 30<br> 度，后面画的所有东西都会歪 30 度，直到你把它转回来（或者用 restore 读档）。</p><ol start="2"><li>旧版 OpenGL (glBegin/glEnd 时代)<br> 其实，早期的 OpenGL (1.x / 2.x) 和 Canvas 非常像。它也有：</li></ol><ul><li>glPushMatrix() (对应 ctx.save())</li><li>glPopMatrix() (对应 ctx.restore())</li></ul><p>那时也是靠操作全局矩阵堆栈来画图的。但这种方式效率较低，在现代高性能图形开发中已经被淘汰了。</p><p>总结：</p><ul><li>Canvas 2D：由于是简化的高级 API，沿用了“状态机”模式，所以需要 save/restore 来隔离状态。</li><li>现代 OpenGL：基于数据驱动，每个物体带着自己的矩阵数据去渲染，互不干扰，所以不需要这种“存档/读档”的操作。</li></ul>',24)]))}]]),s=JSON.parse('{"path":"/posts/Graphics/Canvas_vs_OpenGL.html","title":"绘制两个rect相反方向旋转为什么要调用canvas save","lang":"zh-CN","frontmatter":{"date":"2025-12-23T00:00:00.000Z","tag":["Graphics","AI_GEN"],"description":"绘制两个rect相反方向旋转为什么要调用canvas save Code ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✓ Edit gemini_ver_mod.html:...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"绘制两个rect相反方向旋转为什么要调用canvas save\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-12-23T00:00:00.000Z\\",\\"dateModified\\":\\"2025-12-23T10:08:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/Graphics/Canvas_vs_OpenGL.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"绘制两个rect相反方向旋转为什么要调用canvas save"}],["meta",{"property":"og:description","content":"绘制两个rect相反方向旋转为什么要调用canvas save Code ╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │ ✓ Edit gemini_ver_mod.html:..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-12-23T10:08:23.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:tag","content":"Graphics"}],["meta",{"property":"article:published_time","content":"2025-12-23T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-12-23T10:08:23.000Z"}]]},"git":{"createdTime":1766484503000,"updatedTime":1766484503000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":3.09,"words":927},"filePathRelative":"posts/Graphics/Canvas_vs_OpenGL.md","excerpt":"\\n<h2>Code</h2>\\n<p>╭────────────────────────────────────────────────────────────────────────────────────────────────────────────╮<br>\\n│ ✓  Edit gemini_ver_mod.html:         // 画一些旋转的粒子或线条... =&gt;         // 画一些旋转的粒子或线条...  │<br>\\n│                                                                                                            │<br>\\n│  96   angle += 30 / (radius + 10);                                                                         │<br>\\n│  97   const a = 2; //6                                                                                     │<br>\\n│  98   for (let i = 0; i &lt; a; i++) {                                                                        │<br>\\n│  99 -     canvasCtx.rotate(angle + (i * Math.PI / 3));                                                     │<br>\\n│  99 +     canvasCtx.save();                                                                                │<br>\\n│ 100 +     const direction = (i === 0) ? 1 : -1;                                                            │<br>\\n│ 101 +     canvasCtx.rotate(direction * angle + (i * Math.PI / 4)); // Offset of 45 deg                     │<br>\\n│ 102       canvasCtx.strokeRect(-radius/2, -radius/2, radius, radius);                                      │<br>\\n│ 103 +     canvasCtx.restore();                                                                             │<br>\\n│ 104   }                                                                                                    │<br>\\n│ 105                                                                                                        │<br>\\n│ 106   // 画粒子点                                                                                          │<br>\\n╰────────────────────────────────────────────────────────────────────────────────────────────────────────────╯<br>\\n✦ The two rectangles now rotate in opposite directions (one clockwise, one counter-clockwise) with a slight<br>\\ninitial offset.</p>","autoDesc":true}')}}]);