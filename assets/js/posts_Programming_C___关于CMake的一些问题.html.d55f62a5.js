"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[9781],{628:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,s]of a)i[e]=s;return i}},3101:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>n,data:()=>d});var s=i(8178);const t={},n=(0,i(628).A)(t,[["render",function(e,a){return(0,s.uX)(),(0,s.CE)("div",null,a[0]||(a[0]=[(0,s.Fv)('<h1 id="关于cmake的一些问题" tabindex="-1"><a class="header-anchor" href="#关于cmake的一些问题"><span>关于CMake的一些问题</span></a></h1><h2 id="cmake和gnu-make-ninja可以结合使用-和这些构建程序的区别是什么" tabindex="-1"><a class="header-anchor" href="#cmake和gnu-make-ninja可以结合使用-和这些构建程序的区别是什么"><span>CMake和GNU make, ninja可以结合使用，和这些构建程序的区别是什么</span></a></h2><h3 id="分别做了什么事" tabindex="-1"><a class="header-anchor" href="#分别做了什么事"><span>分别做了什么事</span></a></h3><p>Runner2011:<br> 首先，他们都是项目构建工具，构建好项目后，编译阶段需要调编译器(g++, clang, MSVC等等)生成可执行文件。<br> CMake主要为解决跨平台构建问题，更在make, ninja上一层。编写跨平台CMake文件，通过指定具体构建程序（eg. make, ninja等等)，让他们<strong>处理对应平台问题</strong>，生成给编译器需要的编译单元，头文件等等信息。</p><h2 id="target-include-directories-myapp-private-cmake-source-dir-src-header-中private什么意思" tabindex="-1"><a class="header-anchor" href="#target-include-directories-myapp-private-cmake-source-dir-src-header-中private什么意思"><span>target_include_directories(MyApp PRIVATE ${CMAKE_SOURCE_DIR}/src/header)中PRIVATE什么意思</span></a></h2><p>目标对头文件的可见性。PRIVATE只给当前目标用，PUBLIC也给其他引用当前的目标或库用。</p><table><thead><tr><th>关键词</th><th>含义</th></tr></thead><tbody><tr><td><code>PRIVATE</code></td><td>仅当前目标需要这些 include 路径或库，<strong>不会传播给依赖它的目标</strong></td></tr><tr><td><code>PUBLIC</code></td><td>当前目标需要，同时<strong>依赖它的其他目标也需要</strong></td></tr><tr><td><code>INTERFACE</code></td><td>当前目标<strong>自己不需要</strong>，但是它的使用者（依赖者）<strong>需要</strong></td></tr></tbody></table><h2 id="cmake-source-dir是内置变量吗" tabindex="-1"><a class="header-anchor" href="#cmake-source-dir是内置变量吗"><span>CMAKE_SOURCE_DIR是内置变量吗？</span></a></h2><p>是的，类似其他内置变量还有：</p><table><thead><tr><th>变量名</th><th>含义</th></tr></thead><tbody><tr><td><code>CMAKE_SOURCE_DIR</code></td><td>顶层 CMake 项目的根目录（通常是你放 <code>CMakeLists.txt</code> 的地方）</td></tr><tr><td><code>CMAKE_CURRENT_SOURCE_DIR</code></td><td>当前处理的 <code>CMakeLists.txt</code> 所在目录</td></tr><tr><td><code>CMAKE_BINARY_DIR</code></td><td>构建目录（即 <code>cmake ..</code> 时的 build 目录）</td></tr><tr><td><code>CMAKE_CURRENT_BINARY_DIR</code></td><td>当前处理目录对应的 build 目录</td></tr></tbody></table><h2 id="cmake想用通配符或者-for-循环添加多个cpp文件" tabindex="-1"><a class="header-anchor" href="#cmake想用通配符或者-for-循环添加多个cpp文件"><span>CMake想用通配符或者 for 循环添加多个cpp文件</span></a></h2><h3 id="手动列出-foreach-可选组合" tabindex="-1"><a class="header-anchor" href="#手动列出-foreach-可选组合"><span>手动列出 + <code>foreach(...)</code>（可选组合）</span></a></h3><p>你也可以手动列文件名 + foreach 循环构建变量，比如文件非常分散时：</p><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(SRC_NAMES main math utils io)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(SRC_DIR src)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(SRC_FILES </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">foreach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> IN LISTS SRC_NAMES)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    list</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(APPEND SRC_FILES </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;${SRC_DIR}/${name}.cpp&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">endforeach</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_executable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(MyApp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">${SRC_FILES}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="多目录项目用-glob-recurse-递归搜索-通配符匹配" tabindex="-1"><a class="header-anchor" href="#多目录项目用-glob-recurse-递归搜索-通配符匹配"><span>多目录项目用 GLOB_RECURSE（递归搜索）通配符匹配</span></a></h3><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">file</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS</span></span>\n<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">    &quot;${CMAKE_SOURCE_DIR}/src/*.cpp&quot;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_executable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(MyApp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">${SRC_FILES}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加上 <code>CONFIGURE_DEPENDS</code> 可以在你新加文件后自动触发重新配置。这个是一个可选项，可以不加。</p><h2 id="file-的参数和add-executable-target-include-directories不统一呢-file路径是字符串-后者是变量" tabindex="-1"><a class="header-anchor" href="#file-的参数和add-executable-target-include-directories不统一呢-file路径是字符串-后者是变量"><span>file 的参数和add_executable， target_include_directories不统一呢，file路径是字符串，后者是变量</span></a></h2><h3 id="🧠-简洁回答" tabindex="-1"><a class="header-anchor" href="#🧠-简洁回答"><span>🧠 简洁回答：</span></a></h3><table><thead><tr><th>命令</th><th>参数是字符串</th><th>参数是变量</th></tr></thead><tbody><tr><td><code>file(GLOB ...)</code></td><td>✅ 是路径字符串（带通配符）</td><td></td></tr><tr><td><code>add_executable(...)</code></td><td>✅ 是变量（或具体的文件列表）</td><td></td></tr><tr><td><code>target_include_directories(...)</code></td><td>✅ 是路径变量或字符串（不带通配符）</td><td></td></tr></tbody></table><hr><h3 id="🔍-深度解析" tabindex="-1"><a class="header-anchor" href="#🔍-深度解析"><span>🔍 深度解析：</span></a></h3><h4 id="_1️⃣-file-glob-var-src-cpp" tabindex="-1"><a class="header-anchor" href="#_1️⃣-file-glob-var-src-cpp"><span>1️⃣ <code>file(GLOB VAR &quot;src/*.cpp&quot;)</code></span></a></h4><ul><li><p><code>file()</code> 是 <strong>一个操作命令</strong>，会：</p><ul><li><strong>执行通配符匹配</strong></li><li>把结果列表赋值到变量 <code>VAR</code> 中</li></ul></li><li><p>参数 <code>&quot;src/*.cpp&quot;</code> 是一个 <strong>字符串字面量</strong>，你写的是匹配规则</p></li><li><p>它的结果必须是变量（如 <code>${VAR}</code>）才能传给 <code>add_executable</code> 等命令</p></li></ul><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">file</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(GLOB SRC_FILES </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;src/*.cpp&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 匹配通配符，结果写入变量</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">add_executable</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(MyApp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">${SRC_FILES}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 使用变量</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h4 id="_2️⃣-add-executable-myapp-main-cpp-foo-cpp-add-executable-myapp-src-files" tabindex="-1"><a class="header-anchor" href="#_2️⃣-add-executable-myapp-main-cpp-foo-cpp-add-executable-myapp-src-files"><span>2️⃣ <code>add_executable(MyApp main.cpp foo.cpp)</code> / <code>add_executable(MyApp ${SRC_FILES})</code></span></a></h4><ul><li><p><code>add_executable</code> 只接受 <strong>文件列表</strong></p></li><li><p>这个文件列表可以是：</p><ul><li>一个个文件名字符串</li><li>或一个变量（变量中存了多个文件名）</li></ul></li></ul><p>✅ 不支持通配符，也不会帮你匹配路径。</p><hr><h4 id="_3️⃣-target-include-directories-myapp-private-include" tabindex="-1"><a class="header-anchor" href="#_3️⃣-target-include-directories-myapp-private-include"><span>3️⃣ <code>target_include_directories(MyApp PRIVATE include/)</code></span></a></h4><ul><li>可以写字符串，也可以写变量，但本质是「一组目录路径」，<strong>不支持通配符</strong></li><li>这些目录只是让编译器加到 <code>-I</code> 参数中</li><li>一般这样写没问题：</li></ul><div class="language-cmake line-numbers-mode" data-highlighter="shiki" data-ext="cmake" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cmake"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">target_include_directories</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(MyApp PRIVATE include/ </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">${EXTRA_INCLUDE_DIRS}</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h3 id="🎯-小总结-通俗类比" tabindex="-1"><a class="header-anchor" href="#🎯-小总结-通俗类比"><span>🎯 小总结（通俗类比）：</span></a></h3><table><thead><tr><th>CMake命令</th><th>你写的是...</th><th>背后含义</th></tr></thead><tbody><tr><td><code>file(GLOB VAR &quot;src/*.cpp&quot;)</code></td><td>💬 描述一个“查询规则”</td><td>CMake 帮你“执行查询”，结果放进变量</td></tr><tr><td><code>add_executable(MyApp ${VAR})</code></td><td>📦 塞入“一个已有列表变量”</td><td>只是读取变量的内容，不支持通配符</td></tr><tr><td><code>target_include_directories()</code></td><td>🧭 列出“路径清单”（变量或字符串均可）</td><td>把这些路径加到 <code>-I</code> 编译参数</td></tr></tbody></table>',37)]))}]]),d=JSON.parse('{"path":"/posts/Programming/C__/%E5%85%B3%E4%BA%8ECMake%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html","title":"关于CMake的一些问题","lang":"zh-CN","frontmatter":{"date":"2025-08-06T00:00:00.000Z","tag":["AI_GEN"],"description":"关于CMake的一些问题 CMake和GNU make, ninja可以结合使用，和这些构建程序的区别是什么 分别做了什么事 Runner2011: 首先，他们都是项目构建工具，构建好项目后，编译阶段需要调编译器(g++, clang, MSVC等等)生成可执行文件。 CMake主要为解决跨平台构建问题，更在make, ninja上一层。编写跨平台CM...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"关于CMake的一些问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-06T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-12T07:42:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/Programming/C__/%E5%85%B3%E4%BA%8ECMake%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"关于CMake的一些问题"}],["meta",{"property":"og:description","content":"关于CMake的一些问题 CMake和GNU make, ninja可以结合使用，和这些构建程序的区别是什么 分别做了什么事 Runner2011: 首先，他们都是项目构建工具，构建好项目后，编译阶段需要调编译器(g++, clang, MSVC等等)生成可执行文件。 CMake主要为解决跨平台构建问题，更在make, ninja上一层。编写跨平台CM..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-12T07:42:29.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:published_time","content":"2025-08-06T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-12T07:42:29.000Z"}]]},"git":{"createdTime":1754414453000,"updatedTime":1754984549000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":2,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":3.04,"words":911},"filePathRelative":"posts/Programming/C++/关于CMake的一些问题.md","excerpt":"\\n<h2>CMake和GNU make, ninja可以结合使用，和这些构建程序的区别是什么</h2>\\n<h3>分别做了什么事</h3>\\n<p>Runner2011:<br>\\n首先，他们都是项目构建工具，构建好项目后，编译阶段需要调编译器(g++, clang, MSVC等等)生成可执行文件。<br>\\nCMake主要为解决跨平台构建问题，更在make, ninja上一层。编写跨平台CMake文件，通过指定具体构建程序（eg. make, ninja等等)，让他们<strong>处理对应平台问题</strong>，生成给编译器需要的编译单元，头文件等等信息。</p>\\n<h2>target_include_directories(MyApp PRIVATE ${CMAKE_SOURCE_DIR}/src/header)中PRIVATE什么意思</h2>","autoDesc":true}')}}]);