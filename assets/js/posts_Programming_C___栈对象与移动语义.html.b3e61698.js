"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[5611],{628:(s,i)=>{i.A=(s,i)=>{const a=s.__vccOpts||s;for(const[s,n]of i)a[s]=n;return a}},2595:(s,i,a)=>{a.r(i),a.d(i,{comp:()=>e,data:()=>t});var n=a(8178);const l={},e=(0,a(628).A)(l,[["render",function(s,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h1 id="栈对象与移动语义" tabindex="-1"><a class="header-anchor" href="#栈对象与移动语义"><span>栈对象与移动语义</span></a></h1><h2 id="栈对象超出作用域-使用会怎样" tabindex="-1"><a class="header-anchor" href="#栈对象超出作用域-使用会怎样"><span>栈对象超出作用域，使用会怎样</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Foo</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public:</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    float</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123.123</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Foo</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> f;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Foo foo;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 栈上</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        f </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;"> &amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">foo;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // f 指向即将销毁的对象</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::cout </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">-&gt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::endl;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>按 C++ 标准来说，这是未定义行为（Undefined Behavior, UB）。<br> 原因：foo 是一个栈对象，出了大括号作用域就已经被销毁，指针 f 指向的是悬空（dangling）地址。</p><p>为什么在你的测试里还能打印出正确的值？</p><p><strong>栈内存没有被立刻覆盖</strong><br> 当 foo 出作用域时，它的析构函数执行，生命周期结束。但编译器并不会立刻“清零”或者“收回”这块栈空间，而只是把栈指针 rsp/esp 向上移动。<br> 因此 f 依然指向那块“旧的”内存，而里面的数据还没被别的东西覆盖，就能“看似正确”地打印出来。</p><p><strong>编译器优化行为</strong><br> 在 main 的后续代码里几乎没做其他操作，所以编译器生成的指令不会写入那片栈区，foo.a 的比特模式就完整保留下来。</p><p><strong>运气因素</strong><br> 如果你在 {} 之后再定义其他变量、或者打开优化、或者换编译器，那块内存就很可能被覆盖，打印结果可能变成乱值，甚至程序崩溃。</p><h2 id="栈对象的引用-用std-move可以避免悬空的问题吗" tabindex="-1"><a class="header-anchor" href="#栈对象的引用-用std-move可以避免悬空的问题吗"><span>栈对象的引用，用std::move可以避免悬空的问题吗</span></a></h2><p><strong>不能用 <code>std::move</code> 来避免悬空引用</strong>。</p><p>下面详细解释：</p><hr><h3 id="_1-什么是悬空引用" tabindex="-1"><a class="header-anchor" href="#_1-什么是悬空引用"><span>1. 什么是悬空引用？</span></a></h3><p>如果函数返回局部变量的引用，例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 局部变量</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">               // ❌ 返回局部变量引用 → 悬空</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当函数结束时，<code>s</code> 已经被销毁，返回的引用指向已释放的内存，后续访问就是未定义行为。</p><hr><h3 id="_2-std-move-能干什么" tabindex="-1"><a class="header-anchor" href="#_2-std-move-能干什么"><span>2. <code>std::move</code> 能干什么？</span></a></h3><p><code>std::move</code> <strong>不会延长对象的生命周期</strong>。<br> 它只是一个<strong>类型转换工具</strong>，把左值转为右值引用，从而启用移动语义。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> bar</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 合法，触发移动构造</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种情况下返回的是一个 <strong>新对象（值返回）</strong>，并不是引用。<br> 而栈对象<code>s</code> 还是会被销毁，只是它的内容被“搬走”了。</p><hr><h3 id="_3-为什么-std-move-不能解决悬空引用" tabindex="-1"><a class="header-anchor" href="#_3-为什么-std-move-不能解决悬空引用"><span>3. 为什么 <code>std::move</code> 不能解决悬空引用？</span></a></h3><p>如果函数返回类型是 <strong>引用</strong>：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // ❌ 仍然返回局部变量引用</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里即使用了 <code>std::move</code>，返回的还是 <code>s</code> 的引用。<br> 但 <code>s</code> 在函数结束后一样销毁，所以还是悬空引用 → <strong>未定义行为</strong>。</p><hr><h3 id="_4-正确的做法" tabindex="-1"><a class="header-anchor" href="#_4-正确的做法"><span>4. 正确的做法</span></a></h3><p>如果你想避免悬空，有几个选项：</p><ul><li><p><strong>改成值返回（推荐）</strong></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    std::string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // C++17 起 RVO/NRVO 通常会消除拷贝</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>返回静态对象的引用（不总是合适）</strong></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 生命周期延长到程序结束</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这意味着所有调用共享同一个对象，不适合需要独立结果的场景。</p></li><li><p><strong>由调用者传入输出参数</strong></p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> grid</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    out </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;abc&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="_5-结论" tabindex="-1"><a class="header-anchor" href="#_5-结论"><span>5. 结论</span></a></h3><p><code>std::move</code> <strong>只能触发移动构造或移动赋值</strong>，不能改变生命周期。<br> 如果函数返回的是局部变量的引用，不管有没有 <code>std::move</code>，都会悬空。</p><h2 id="std-move搬走的栈对象的什么东西" tabindex="-1"><a class="header-anchor" href="#std-move搬走的栈对象的什么东西"><span>std::move搬走的栈对象的什么东西？</span></a></h2><p>Q:如果a是栈对象，它的数据放到栈上，数据会随着作用域消失吧？不重新复制一份，怎么避免数据从栈上消失的问题呢？</p><blockquote><p>runner2011: 简而言之，如果move的对象有堆内存，就用指针引用加清理原对象引用‘偷过来’。如果move的对象所有数据都存在栈上，那移动构造则没有太大意义，还是得把move对象的数据做memcopy.</p></blockquote><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">   // 调用移动构造函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>发生了什么？<br> b 直接接管 a 的堆内存指针（“搬家”）。<br> a 被“置空”（比如指针设为 nullptr），但依然是合法对象。<br> 成本：只是指针赋值 + 清理 a，没有真正拷贝字符数组。<br> 结果：更高效。</p><hr><p>这个问题问得非常到位 👍。你直觉上觉得：</p><blockquote><p>如果对象 <code>a</code> 在栈上，那它的“数据”不也跟着栈一起消失了吗？<br> 移动构造只是“偷指针”，那数据不就没了？</p></blockquote><p>关键在于：<strong>要区分“对象本身在栈上”</strong> 和 <strong>“对象管理的资源存放位置”</strong>。</p><hr><h3 id="_1-栈对象-vs-堆资源" tabindex="-1"><a class="header-anchor" href="#_1-栈对象-vs-堆资源"><span>1. 栈对象 vs 堆资源</span></a></h3><p>举个例子：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string a </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><code>a</code> 本身是一个 <strong>栈对象</strong>，它包含三个成员：</p><ul><li>一个 <code>char*</code> 指针（指向堆内存），</li><li>一个 size，</li><li>一个 capacity。</li></ul></li></ul><p>这些元数据（指针和数字）在 <strong>栈上</strong>。</p><ul><li>实际的字符数据 <code>&quot;hello&quot;</code> 存在 <strong>堆上</strong>（由 <code>std::string</code> 内部 new 出来）。</li></ul><p>所以：</p><ul><li>当 <code>a</code> 作用域结束 → 栈上那一小块元数据会消失。</li><li>但是堆上的数据要靠析构函数手动 <code>delete[]</code>。</li></ul><hr><h3 id="_2-拷贝构造的做法" tabindex="-1"><a class="header-anchor" href="#_2-拷贝构造的做法"><span>2. 拷贝构造的做法</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>b</code> 在栈上新建一个指针 + size + capacity。</li><li><strong>重新分配堆内存</strong>，拷贝 <code>&quot;hello&quot;</code>。</li><li>成本高。</li></ul><hr><h3 id="_3-移动构造的做法" tabindex="-1"><a class="header-anchor" href="#_3-移动构造的做法"><span>3. 移动构造的做法</span></a></h3><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string b </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">move</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(a);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><code>b</code> 在栈上新建一个指针 + size + capacity。</li><li>直接 <strong>偷走 <code>a</code> 的指针</strong>，让它指向 <code>&quot;hello&quot;</code> 那块堆内存。</li><li><code>a</code> 的指针被置为 <code>nullptr</code>，size = 0。</li></ul><p>这样：</p><ul><li>堆里的 <code>&quot;hello&quot;</code> 还在，并且现在由 <code>b</code> 管理。</li><li><code>a</code> 已经是“空壳”，析构时不会去释放那块内存（因为指针被清空了）。</li><li>最终由 <code>b</code> 在析构时释放那块堆内存。</li></ul><hr><h3 id="_4-为什么不会出错" tabindex="-1"><a class="header-anchor" href="#_4-为什么不会出错"><span>4. 为什么不会出错？</span></a></h3><p>因为所谓的“数据消失”，只发生在<strong>纯栈对象的数据</strong>。<br> 但对于大部分需要移动优化的类型（<code>std::string</code>, <code>std::vector</code>, …），它们的<strong>大数据部分在堆上</strong>。<br> 移动构造只是在栈上“换了个指针的主人”，堆里的真实数据不动。</p><hr><h3 id="_5-特殊情况" tabindex="-1"><a class="header-anchor" href="#_5-特殊情况"><span>5. 特殊情况</span></a></h3><p>如果一个类的数据完全在栈上（比如 <code>struct { int a[100]; };</code>），那就没什么堆资源可偷了。<br> 编译器生成的 <strong>移动构造</strong>和<strong>拷贝构造</strong>在这种情况下几乎一样，都是 memcpy 一份。</p><hr><h3 id="_6-直观比喻" tabindex="-1"><a class="header-anchor" href="#_6-直观比喻"><span>6. 直观比喻</span></a></h3><ul><li><strong>拷贝构造</strong>：你买了一个新房子（新堆内存），把旧房子的家具（数据）一件件搬过去。</li><li><strong>移动构造</strong>：你直接把房契（指针）过户，家具（堆内存）一动不动。旧房子变空壳。</li></ul><hr><p>✅ 总结：</p><ul><li><code>a</code> 是栈对象没错，但它大部分数据存放在堆上。</li><li>移动构造不会复制堆上的内容，而是把堆资源的“所有权”转交给新对象。</li><li>栈上的“旧元数据”随作用域消失没关系，堆数据仍然存在，直到新的对象释放它。</li></ul><h2 id="const-绑定到一个临时对象时-编译器会延长该临时对象的生命周期-直到引用变量的作用域结束" tabindex="-1"><a class="header-anchor" href="#const-绑定到一个临时对象时-编译器会延长该临时对象的生命周期-直到引用变量的作用域结束"><span>const&amp; 绑定到一个临时对象时，编译器会延长该临时对象的生命周期，直到引用变量的作用域结束</span></a></h2><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  string s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s;</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // error</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // correct.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="c-引用绑定规则" tabindex="-1"><a class="header-anchor" href="#c-引用绑定规则"><span>C++ 引用绑定规则</span></a></h3><ul><li><p>非 const 左值引用 (T&amp;)<br> 只能绑定到 已有的左值对象。<br> （必须是名字存在、生命周期明确的对象）</p></li><li><p>const 左值引用 (const T&amp;)<br> 可以绑定到 任何对象，包括临时对象（右值）。</p></li></ul><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><blockquote><p>⚠️ 注意：这是 C++ 标准特殊规则, 这样可以引用临时对象，并且临时对象的生命周期会被延长到 str 的作用域结束。</p></blockquote><ul><li>右值引用 (T&amp;&amp;)<br> 专门用来绑定右值。</li></ul><p>想修改返回的临时对象<br> 可以用右值引用：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> str </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但一般不这么用，除非你要在 str 上做就地修改。</p><h2 id="q-但我还是觉得-用const-绑定到一个临时对象时-编译器会-延长该临时对象的生命周期的做法-把语言特性变得复杂化了-因该避免。" tabindex="-1"><a class="header-anchor" href="#q-但我还是觉得-用const-绑定到一个临时对象时-编译器会-延长该临时对象的生命周期的做法-把语言特性变得复杂化了-因该避免。"><span>Q:但我还是觉得，用const&amp; 绑定到一个临时对象时，编译器会 延长该临时对象的生命周期的做法，把语言特性变得复杂化了，因该避免。</span></a></h2><p>你这个感觉其实挺对的 👍，很多老一辈 C++ 开发者当年也有同样的吐槽：</p><ul><li><strong>没有 <code>const&amp;</code> 特例的世界会更简单</strong>：右值只能绑定右值引用，左值只能绑定左值引用。</li><li>但是 C++ 的设计哲学是“兼顾效率和便利”，于是语言标准委员会在早期就引入了这个“生命周期延长”的规则。</li></ul><hr><h3 id="为什么-c-要引入这个特例" tabindex="-1"><a class="header-anchor" href="#为什么-c-要引入这个特例"><span>为什么 C++ 要引入这个特例？</span></a></h3><h4 id="_1-历史原因-c-98-之前就有" tabindex="-1"><a class="header-anchor" href="#_1-历史原因-c-98-之前就有"><span>1. 历史原因（C++98 之前就有）</span></a></h4><p>在 C++ 里，临时对象（右值）本来寿命很短，如果你不能引用它，就会很麻烦。<br> 例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">s</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; world&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><p><code>&quot;hello&quot;s + &quot; world&quot;s</code> 会生成一个临时 <code>std::string</code>。</p></li><li><p>如果没有 <code>const&amp;</code> 特例，你必须写成：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-cpp"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string tmp </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;hello&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">s</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> +</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot; world&quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">s</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>\n<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tmp;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>既啰嗦，又浪费性能（以前优化器还没那么强）。</p></li></ul><p>所以当年标准委员会觉得：允许 <code>const&amp;</code> 引用临时，可以少写一大堆临时变量。</p><hr><h4 id="_2-安全性考虑" tabindex="-1"><a class="header-anchor" href="#_2-安全性考虑"><span>2. 安全性考虑</span></a></h4><ul><li><p><code>const&amp;</code> <strong>不能修改</strong>临时对象 → 风险很小。</p></li><li><p>于是 C++ 就干脆加了一个编译器保证：</p><blockquote><p>“只要有 <code>const&amp;</code> 绑定到临时，我就延长临时的生命周期。”</p></blockquote></li></ul><p>这样就避免了悬空引用问题。</p><hr><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><p>你说的对，这确实让 C++ 的语义复杂化了：</p><ul><li><strong>学习曲线更陡峭</strong>：初学者经常疑惑“为什么 <code>string&amp;</code> 不行，<code>const string&amp;</code> 却可以？”</li><li><strong>规则很诡异</strong>：生命周期延长只对 <code>const&amp;</code> 有效，对 <code>T&amp;&amp;</code> 和 <code>T&amp;</code> 都没效，导致“规则碎片化”。</li></ul><hr><h3 id="现代-c-的替代思路" tabindex="-1"><a class="header-anchor" href="#现代-c-的替代思路"><span>现代 C++ 的替代思路</span></a></h3><p>很多 C++ Core Guidelines 建议：</p><blockquote><p><strong>尽量返回值（by value），不要过度依赖 <code>const&amp;</code> 绑定右值。</strong></p></blockquote><p>原因：</p><ul><li>从 C++11 开始有了 <strong>移动语义</strong> 和 <strong>返回值优化 (RVO/NRVO)</strong>，返回值成本大大降低。</li><li>代码更直观：<code>std::string s = foo();</code> 一看就知道 <code>s</code> 是自己的一份，不受别人生命周期影响。</li><li>只有在性能瓶颈或避免拷贝时，才会考虑 <code>const&amp;</code>。</li></ul><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><ul><li>你说的没错：<code>const&amp;</code> 绑定右值确实让语言更复杂。</li><li>这是 <strong>历史遗留 + 工程便利性</strong> 的产物。</li><li>在现代 C++，大多数情况下我们更推荐直接 <strong>值返回</strong> 或 <strong>用 <code>auto</code> 接收返回值</strong>，而不是依赖这个规则。</li></ul>',111)]))}]]),t=JSON.parse('{"path":"/posts/Programming/C__/%E6%A0%88%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89.html","title":"栈对象与移动语义","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"栈对象与移动语义 栈对象超出作用域，使用会怎样 按 C++ 标准来说，这是未定义行为（Undefined Behavior, UB）。 原因：foo 是一个栈对象，出了大括号作用域就已经被销毁，指针 f 指向的是悬空（dangling）地址。 为什么在你的测试里还能打印出正确的值？ 栈内存没有被立刻覆盖 当 foo 出作用域时，它的析构函数执行，生命周...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"栈对象与移动语义\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-18T14:12:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/Programming/C__/%E6%A0%88%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"栈对象与移动语义"}],["meta",{"property":"og:description","content":"栈对象与移动语义 栈对象超出作用域，使用会怎样 按 C++ 标准来说，这是未定义行为（Undefined Behavior, UB）。 原因：foo 是一个栈对象，出了大括号作用域就已经被销毁，指针 f 指向的是悬空（dangling）地址。 为什么在你的测试里还能打印出正确的值？ 栈内存没有被立刻覆盖 当 foo 出作用域时，它的析构函数执行，生命周..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-18T14:12:58.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2025-08-18T14:12:58.000Z"}]]},"git":{"createdTime":1755526378000,"updatedTime":1755526378000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":8.58,"words":2575},"filePathRelative":"posts/Programming/C++/栈对象与移动语义.md","excerpt":"\\n<h2>栈对象超出作用域，使用会怎样</h2>\\n<div class=\\"language-cpp line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"cpp\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code class=\\"language-cpp\\"><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">class</span><span style=\\"--shiki-light:#C18401;--shiki-dark:#E5C07B\\"> Foo</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    public:</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    float</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> a </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">=</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\"> 123.123</span><span style=\\"--shiki-light:#986801;--shiki-dark:#E06C75\\">f</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">};</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">int</span><span style=\\"--shiki-light:#4078F2;--shiki-dark:#61AFEF\\"> main</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">()</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">{</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    Foo</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">*</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> f;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    {</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">        Foo foo;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">   // 栈上</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">        f </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">=</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#56B6C2\\"> &amp;</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">foo;</span><span style=\\"--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic\\">  // f 指向即将销毁的对象</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    } </span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">    std::cout </span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">&lt;&lt;</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E5C07B\\"> f</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">-&gt;</span><span style=\\"--shiki-light:#E45649;--shiki-dark:#E06C75\\">a</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\"> &lt;&lt;</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> std::endl;</span></span>\\n<span class=\\"line\\"></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">    return</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\"> 0</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;</span></span>\\n<span class=\\"line\\"><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);