"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[635],{628:(t,n)=>{n.A=(t,n)=>{const r=t.__vccOpts||t;for(const[t,o]of n)r[t]=o;return r}},9587:(t,n,r)=>{r.r(n),r.d(n,{comp:()=>g,data:()=>l});var o=r(8178);const s={},g=(0,r(628).A)(s,[["render",function(t,n){return(0,o.uX)(),(0,o.CE)("div",null,n[0]||(n[0]=[(0,o.Fv)('<h1 id="cpu与fpga" tabindex="-1"><a class="header-anchor" href="#cpu与fpga"><span>CPU与FPGA</span></a></h1><h2 id="fpga和cpu的根本差别是什么-讲讲二者分别适合做什么" tabindex="-1"><a class="header-anchor" href="#fpga和cpu的根本差别是什么-讲讲二者分别适合做什么"><span>FPGA和CPU的根本差别是什么？讲讲二者分别适合做什么</span></a></h2><p>好的，我们先把 FPGA 和 CPU 的根本区别拆开来说，再看看各自的应用场景。</p><hr><h3 id="fpga-和-cpu-的根本差别" tabindex="-1"><a class="header-anchor" href="#fpga-和-cpu-的根本差别"><span>FPGA 和 CPU 的根本差别</span></a></h3><ol><li><p><strong>计算方式（可编程性 vs 指令执行）</strong></p><ul><li><strong>CPU</strong>：通用处理器，通过执行存储在内存里的<strong>指令序列</strong>来工作。它有固定的算术逻辑单元、寄存器、缓存等硬件结构，所有操作都依赖“顺序执行或有限并行”的指令流。</li><li><strong>FPGA</strong>：可编程逻辑阵列，硬件本身可以按用户设计<strong>直接改变连接方式</strong>，在硬件级别实现自定义电路。换句话说，FPGA不是“执行程序”，而是“变成你想要的电路”去做任务。</li></ul></li><li><p><strong>灵活性 vs 性能优化</strong></p><ul><li><strong>CPU</strong>：高度灵活，几乎可以执行任何软件算法，但硬件是固定的，因此无法在硬件层面做针对性优化。</li><li><strong>FPGA</strong>：灵活性体现在<strong>硬件层面</strong>，可以设计专门的并行电路、流水线结构或者定制的数据路径，从而在特定任务上比 CPU 快很多。</li></ul></li><li><p><strong>并行度</strong></p><ul><li><strong>CPU</strong>：核心数量有限，主要依靠流水线和 SIMD（向量指令）做有限的并行处理。</li><li><strong>FPGA</strong>：可实现极高并行度，比如同时处理数百条数据流，因为每条逻辑路径都可以独立存在。</li></ul></li><li><p><strong>延迟</strong></p><ul><li><strong>CPU</strong>：每条指令的执行有一定调度和缓存延迟。</li><li><strong>FPGA</strong>：延迟非常低，可以直接在硬件级别处理数据流，实现接近零延迟的数据处理。</li></ul></li></ol><hr><h3 id="适合的应用场景" tabindex="-1"><a class="header-anchor" href="#适合的应用场景"><span>适合的应用场景</span></a></h3><ol><li><p><strong>CPU</strong>适合：</p><ul><li>需要<strong>高度灵活性</strong>的任务，比如操作系统、办公软件、游戏逻辑、数据库处理等。</li><li>任务种类多变、算法更新频繁，不值得为每个算法都设计硬件。</li><li>需要处理<strong>复杂控制逻辑</strong>和软件生态支持的场景。</li></ul></li><li><p><strong>FPGA</strong>适合：</p><ul><li><strong>对性能或延迟要求极高</strong>的任务，比如金融高频交易、信号处理、视频编解码、网络包处理。</li><li><strong>高度并行的数据处理</strong>任务，比如深度学习加速器的推理阶段。</li><li><strong>特殊接口或协议</strong>处理，需要在硬件级实现定制逻辑（例如工业控制、通信基站）。</li><li>任务相对固定，<strong>一次设计，多次使用</strong>，能发挥 FPGA 并行硬件优势。</li></ul></li></ol><hr><p>一句话总结：</p><ul><li>CPU = 万能工具，灵活但每个任务性能一般。</li><li>FPGA = 可变硬件，专门设计时速度极快，但开发复杂。</li></ul><hr><p>如果你需要，我可以画一个<strong>CPU 和 FPGA 处理同一任务的对比图</strong>，让差别直观看出来。</p><p>你希望我画吗？</p><h2 id="听起来mac-npu适合做成fpga-高并行数据处理" tabindex="-1"><a class="header-anchor" href="#听起来mac-npu适合做成fpga-高并行数据处理"><span>听起来mac NPU适合做成FPGA？ 高并行数据处理</span></a></h2><p>你的直觉非常敏锐！你观察到了它们在**“高并行数据处理”**这一灵魂特征上的共性。</p><p>但从底层技术路径上来说，苹果 Mac 的 <strong>NPU（Neural Engine）</strong> 并不是 <strong>FPGA</strong>，而是一个极其纯粹的 <strong>ASIC</strong>（专用集成电路）。</p><p>如果说 CPU 是“全能厨师”，FPGA 是“模块化厨房”，那么 <strong>NPU 就是一台“工业级自动切菜机”</strong>——它只干一件事（矩阵运算），但干得比谁都快、都省电。</p><hr><h3 id="_1-为什么你觉得它像-fpga-你的洞察点" tabindex="-1"><a class="header-anchor" href="#_1-为什么你觉得它像-fpga-你的洞察点"><span>1. 为什么你觉得它像 FPGA？（你的洞察点）</span></a></h3><p>你之所以觉得它像 FPGA，是因为它们在处理数据时都采用了**“空间计算”**的思想：</p><ul><li><strong>高吞吐量：</strong> 二者都不像 CPU 那样一次只憋出一个指令，而是成千上万个数据流同时在大规模的算力阵列中穿梭。</li><li><strong>低功耗加速：</strong> 它们都通过绕过 CPU 复杂的取指译码流程，直接在硬件层面完成特定任务，从而大幅降低功耗。</li></ul><h3 id="_2-为什么苹果选-asic-而非-fpga" tabindex="-1"><a class="header-anchor" href="#_2-为什么苹果选-asic-而非-fpga"><span>2. 为什么苹果选 ASIC 而非 FPGA？</span></a></h3><p>虽然 FPGA 也能做成高性能 NPU（很多大公司在实验室里就是这么干的），但苹果为了大规模量产，必须选择 ASIC。</p><table><thead><tr><th>维度</th><th>NPU (ASIC)</th><th>FPGA</th></tr></thead><tbody><tr><td><strong>电路结构</strong></td><td><strong>死板且固定</strong>。晶体管位置出厂即锁定，不可更改。</td><td><strong>可编程</strong>。通过软件重新配置逻辑门之间的连线。</td></tr><tr><td><strong>能效比</strong></td><td><strong>极致省电</strong>。因为没有冗余的配置逻辑，功耗极低。</td><td><strong>耗电较高</strong>。为了保持可编程性，带来了大量额外的电路开销。</td></tr><tr><td><strong>面积/成本</strong></td><td><strong>小而美</strong>。在同样算力下，占用芯片面积更小，适合集成。</td><td><strong>大而贵</strong>。同样算力的 FPGA 面积可能是 ASIC 的 10 倍以上。</td></tr><tr><td><strong>应用场景</strong></td><td><strong>成熟、稳定的算法</strong>（如 Transformer 或卷积运算）。</td><td><strong>快速变动的协议、算法原型开发</strong>（如 5G 基站原型）。</td></tr></tbody></table><hr><h3 id="_3-npu-的-并行-与-fpga-有什么不同" tabindex="-1"><a class="header-anchor" href="#_3-npu-的-并行-与-fpga-有什么不同"><span>3. NPU 的“并行”与 FPGA 有什么不同？</span></a></h3><ul><li><strong>NPU 的并行是“矩阵式的”：</strong> 苹果的 NPU 内部主要是一大堆由硬连线构成的 <strong>MAC（乘累加单元）阵列</strong>。这就像是一排排整齐的计算网格，数据像水流一样通过，瞬间完成矩阵乘法。</li><li><strong>FPGA 的并行是“流水线式的”：</strong> 你可以把 FPGA 配置成任何你想要的形状。它可以像一条长长的传送带，每个零件（逻辑单元）负责一个细微的操作。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>苹果不选 FPGA 的根本原因是：<strong>成本与效率</strong>。<br> 苹果已经把“AI 模型需要矩阵运算”这件事看透了，既然算法框架已经相对稳定，那就干脆用最硬核的方式（ASIC）把这些运算刻在硅片上。这样你的 MacBook 才能在合盖状态下依然能极速处理人脸识别，而且电池还不发烫。</p><p><strong>有趣的一点：</strong> 在苹果正式流片（生产）这一代 NPU 之前，他们的工程师极大概率就是先在<strong>顶级 FPGA</strong> 上跑仿真测试的。</p><p>既然你提到了高并行处理，你想聊聊为什么现在的 <strong>LLM（大语言模型）</strong> 在推理时，NPU 的显存带宽往往比算力本身更容易成为瓶颈吗？</p>',33)]))}]]),l=JSON.parse('{"path":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CPU%E4%B8%8EFPGA.html","title":"CPU与FPGA","lang":"zh-CN","frontmatter":{"date":"2026-02-04T00:00:00.000Z","tag":["AI_GEN"],"description":"CPU与FPGA FPGA和CPU的根本差别是什么？讲讲二者分别适合做什么 好的，我们先把 FPGA 和 CPU 的根本区别拆开来说，再看看各自的应用场景。 FPGA 和 CPU 的根本差别 计算方式（可编程性 vs 指令执行） CPU：通用处理器，通过执行存储在内存里的指令序列来工作。它有固定的算术逻辑单元、寄存器、缓存等硬件结构，所有操作都依赖“顺...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"CPU与FPGA\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2026-02-04T00:00:00.000Z\\",\\"dateModified\\":\\"2026-02-09T13:42:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/CPU%E4%B8%8EFPGA.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"CPU与FPGA"}],["meta",{"property":"og:description","content":"CPU与FPGA FPGA和CPU的根本差别是什么？讲讲二者分别适合做什么 好的，我们先把 FPGA 和 CPU 的根本区别拆开来说，再看看各自的应用场景。 FPGA 和 CPU 的根本差别 计算方式（可编程性 vs 指令执行） CPU：通用处理器，通过执行存储在内存里的指令序列来工作。它有固定的算术逻辑单元、寄存器、缓存等硬件结构，所有操作都依赖“顺..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-09T13:42:44.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:published_time","content":"2026-02-04T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-09T13:42:44.000Z"}]]},"git":{"createdTime":1770644564000,"updatedTime":1770644564000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":5.16,"words":1547},"filePathRelative":"posts/计算机基础/计算机体系结构/CPU与FPGA.md","excerpt":"\\n<h2>FPGA和CPU的根本差别是什么？讲讲二者分别适合做什么</h2>\\n<p>好的，我们先把 FPGA 和 CPU 的根本区别拆开来说，再看看各自的应用场景。</p>\\n<hr>\\n<h3>FPGA 和 CPU 的根本差别</h3>\\n<ol>\\n<li>\\n<p><strong>计算方式（可编程性 vs 指令执行）</strong></p>\\n<ul>\\n<li><strong>CPU</strong>：通用处理器，通过执行存储在内存里的<strong>指令序列</strong>来工作。它有固定的算术逻辑单元、寄存器、缓存等硬件结构，所有操作都依赖“顺序执行或有限并行”的指令流。</li>\\n<li><strong>FPGA</strong>：可编程逻辑阵列，硬件本身可以按用户设计<strong>直接改变连接方式</strong>，在硬件级别实现自定义电路。换句话说，FPGA不是“执行程序”，而是“变成你想要的电路”去做任务。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>灵活性 vs 性能优化</strong></p>\\n<ul>\\n<li><strong>CPU</strong>：高度灵活，几乎可以执行任何软件算法，但硬件是固定的，因此无法在硬件层面做针对性优化。</li>\\n<li><strong>FPGA</strong>：灵活性体现在<strong>硬件层面</strong>，可以设计专门的并行电路、流水线结构或者定制的数据路径，从而在特定任务上比 CPU 快很多。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>并行度</strong></p>\\n<ul>\\n<li><strong>CPU</strong>：核心数量有限，主要依靠流水线和 SIMD（向量指令）做有限的并行处理。</li>\\n<li><strong>FPGA</strong>：可实现极高并行度，比如同时处理数百条数据流，因为每条逻辑路径都可以独立存在。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>延迟</strong></p>\\n<ul>\\n<li><strong>CPU</strong>：每条指令的执行有一定调度和缓存延迟。</li>\\n<li><strong>FPGA</strong>：延迟非常低，可以直接在硬件级别处理数据流，实现接近零延迟的数据处理。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);