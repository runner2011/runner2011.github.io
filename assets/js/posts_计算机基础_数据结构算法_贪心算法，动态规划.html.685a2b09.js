"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[5363],{628:(t,e)=>{e.A=(t,e)=>{const n=t.__vccOpts||t;for(const[t,a]of e)n[t]=a;return n}},1626:(t,e,n)=>{n.r(e),n.d(e,{comp:()=>l,data:()=>r});var a=n(8178);const s={},l=(0,n(628).A)(s,[["render",function(t,e){const n=(0,a.g2)("RouteLink");return(0,a.uX)(),(0,a.CE)("div",null,[e[7]||(e[7]=(0,a.Lk)("h1",{id:"贪心算法-动态规划",tabindex:"-1"},[(0,a.Lk)("a",{class:"header-anchor",href:"#贪心算法-动态规划"},[(0,a.Lk)("span",null,"贪心算法，动态规划")])],-1)),e[8]||(e[8]=(0,a.Lk)("ul",null,[(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"贪心算法"),(0,a.eW)("：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。")]),(0,a.Lk)("li",null,[(0,a.Lk)("strong",null,"动态规划"),(0,a.eW)("：像一群人分头探索所有路径，最后汇总最优路线")])],-1)),(0,a.Lk)("p",null,[e[1]||(e[1]=(0,a.eW)("动态规划：计算每一个子问题，并记录子问题的结果。")),e[2]||(e[2]=(0,a.Lk)("strong",null,"核心：子问题只算一遍。",-1)),e[3]||(e[3]=(0,a.eW)(" 这个方式来降复杂度，而")),(0,a.bF)(n,{to:"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html"},{default:(0,a.k6)(()=>e[0]||(e[0]=[(0,a.eW)("NP问题")])),_:1,__:[0]}),e[4]||(e[4]=(0,a.eW)("通常不能拆分成")),e[5]||(e[5]=(0,a.Lk)("strong",null,"可复用的子问题",-1)),e[6]||(e[6]=(0,a.eW)("，导致复杂度太高"))]),e[9]||(e[9]=(0,a.Fv)('<p>贪心算法：每次取最解决的结果，一条路走到黑</p><h2 id="贪心算法的问题" tabindex="-1"><a class="header-anchor" href="#贪心算法的问题"><span>贪心算法的问题</span></a></h2><ul><li>是一种快速接近最优解的办法，但可能不是最优解</li><li>动态规划因为考虑了全局（在满足某些条件，暂时不表），可以求出最优解</li></ul><p>举个例子：</p><p>场景设定：<br> 您要去菜市场买菜，家里锅只能煮最多10斤菜，您带了一个“布兜”，最多也只能装10斤。</p><p>市场里<strong>只有这么多重量</strong>的食材：</p><table><thead><tr><th>菜名</th><th>重量（斤）</th><th>美味度（分）</th></tr></thead><tbody><tr><td>西红柿</td><td>2斤</td><td>3分</td></tr><tr><td>土豆</td><td>3斤</td><td>4分</td></tr><tr><td>鸡蛋</td><td>4斤</td><td>5分</td></tr><tr><td>牛肉</td><td>5斤</td><td>8分</td></tr></tbody></table><p>一种常见的满足直觉的算法是，我先买<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>性价比</mtext><mo>=</mo><mtext>美味度</mtext><mi mathvariant="normal">/</mi><mtext>重量</mtext></mrow><annotation encoding="application/x-tex">性价比=美味度/重量</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">性价比</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">美味度</span><span class="mord">/</span><span class="mord cjk_fallback">重量</span></span></span></span>最高的食材，以此类推。分别是牛肉（1.6），西红柿（1.5），土豆（1.33），鸡蛋（1.25）。<br> 10斤可以得15分美味度。这个就是最优解。然后把限制改到9斤时，这个算法，只能买牛肉+西红柿（9分），错过了牛肉+鸡蛋（13分）的最优解。<strong>这个算法就叫贪心算法</strong></p><p>而<strong>动态规划</strong>，<br> #TODO</p><h2 id="性能" tabindex="-1"><a class="header-anchor" href="#性能"><span>性能</span></a></h2><table><thead><tr><th style="text-align:left;">维度</th><th style="text-align:left;">贪心算法</th><th style="text-align:left;">动态规划</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>时间效率</strong></td><td style="text-align:left;">快（<code>O(amount)</code>）</td><td style="text-align:left;">慢（<code>O(amount × coin_types)</code>）</td></tr><tr><td style="text-align:left;"><strong>空间效率</strong></td><td style="text-align:left;">低（<code>O(1)</code>）</td><td style="text-align:left;">高（<code>O(amount)</code>）</td></tr><tr><td style="text-align:left;"><strong>解的质量</strong></td><td style="text-align:left;">可能非最优（如 <code>4,1,1</code>）</td><td style="text-align:left;">保证最优（如 <code>3,3</code>）</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">问题满足贪心性质时</td><td style="text-align:left;">通用性强，但需要更多计算</td></tr></tbody></table>',11))])}]]),r=JSON.parse('{"path":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html","title":"贪心算法，动态规划","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"贪心算法，动态规划 贪心算法：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。 动态规划：像一群人分头探索所有路径，最后汇总最优路线 动态规划：计算每一个子问题，并记录子问题的结果。核心：子问题只算一遍。 这个方式来降复杂度，而通常不能拆分成可复用的子问题，导致复杂度太高 贪心算法：每次取最解决的结果，一条路走到黑 贪心算法的问题 是一种快速接近最...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"贪心算法，动态规划\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-28T14:08:06.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"贪心算法，动态规划"}],["meta",{"property":"og:description","content":"贪心算法，动态规划 贪心算法：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。 动态规划：像一群人分头探索所有路径，最后汇总最优路线 动态规划：计算每一个子问题，并记录子问题的结果。核心：子问题只算一遍。 这个方式来降复杂度，而通常不能拆分成可复用的子问题，导致复杂度太高 贪心算法：每次取最解决的结果，一条路走到黑 贪心算法的问题 是一种快速接近最..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T14:08:06.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2025-07-28T14:08:06.000Z"}]]},"git":{"createdTime":1749351682000,"updatedTime":1753711686000,"contributors":[{"name":"Runner2011","username":"Runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/Runner2011"},{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":1.65,"words":494},"filePathRelative":"posts/计算机基础/数据结构算法/贪心算法，动态规划.md","excerpt":"\\n<ul>\\n<li><strong>贪心算法</strong>：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。</li>\\n<li><strong>动态规划</strong>：像一群人分头探索所有路径，最后汇总最优路线</li>\\n</ul>\\n<p>动态规划：计算每一个子问题，并记录子问题的结果。<strong>核心：子问题只算一遍。</strong> 这个方式来降复杂度，而<a href=\\"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/P%E5%92%8CNP%E9%97%AE%E9%A2%98.html\\" target=\\"_blank\\">NP问题</a>通常不能拆分成<strong>可复用的子问题</strong>，导致复杂度太高</p>","autoDesc":true}')}}]);