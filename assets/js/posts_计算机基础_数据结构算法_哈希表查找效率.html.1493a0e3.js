"use strict";(self.webpackChunkrunn2011blog=self.webpackChunkrunn2011blog||[]).push([[8081],{628:(s,n)=>{n.A=(s,n)=>{const e=s.__vccOpts||s;for(const[s,a]of n)e[s]=a;return e}},1067:(s,n,e)=>{e.r(n),e.d(n,{comp:()=>t,data:()=>r});var a=e(8178);const i={},t=(0,e(628).A)(i,[["render",function(s,n){return(0,a.uX)(),(0,a.CE)("div",null,n[0]||(n[0]=[(0,a.Fv)('<h1 id="哈希表查找效率" tabindex="-1"><a class="header-anchor" href="#哈希表查找效率"><span>哈希表查找效率</span></a></h1><h2 id="q-数组的查询效率可以到o1-因为它是顺序存储的。字典的是key-value用hash方式存储的。比如-张三-26-老王-60-小明-5-以hash的数据结构-我要查小明-效率是o1还是o-n" tabindex="-1"><a class="header-anchor" href="#q-数组的查询效率可以到o1-因为它是顺序存储的。字典的是key-value用hash方式存储的。比如-张三-26-老王-60-小明-5-以hash的数据结构-我要查小明-效率是o1还是o-n"><span>Q:数组的查询效率可以到O1，因为它是顺序存储的。字典的是key,value用hash方式存储的。比如{张三，26}，{老王，60}，{小明， 5}. 以hash的数据结构，我要查小明，效率是O1还是O(n)?</span></a></h2><p>如果字典是用哈希表实现的，那么<strong>平均情况下</strong>查找 <code>&quot;小明&quot;</code> 这样的键的时间复杂度是 <strong>O(1)</strong>，因为它会直接通过哈希函数把键映射到一个存储位置，然后一步就能找到对应的值。</p><p>但是有几点需要注意：</p><ol><li><p><strong>平均 O(1)，最坏 O(n)</strong></p><ul><li>如果哈希函数分布均匀、冲突少，那么查找就是常数时间。</li><li>如果哈希冲突非常严重（比如所有 key 都映射到同一个位置），查找就会退化成线性查找 O(n)。</li></ul></li><li><p><strong>哈希表查找的过程</strong></p><ul><li>对键（比如 <code>&quot;小明&quot;</code>）计算哈希值 → 找到哈希桶的位置 → 在该桶中比较键（因为可能冲突） → 返回值。</li><li>桶里如果只有一个元素，就是一步找到；如果有多个元素，就要在桶里线性查找。</li></ul></li><li><p><strong>和数组的区别</strong></p><ul><li>数组下标访问是真正的 O(1) 且最坏也是 O(1)，因为它直接通过 <code>基址 + index * 元素大小</code> 计算内存位置。</li><li>哈希表的 O(1) 是概率意义上的，依赖于哈希函数质量和负载因子（load factor）。</li></ul></li></ol><p>所以你这个 <code>{张三: 26, 老王: 60, 小明: 5}</code> 查 <code>&quot;小明&quot;</code> 在正常情况下是 <strong>O(1)</strong>，但理论上的最坏情况会变成 <strong>O(n)</strong>。</p><h2 id="q-还需要解释为什么哈希最好是o-1" tabindex="-1"><a class="header-anchor" href="#q-还需要解释为什么哈希最好是o-1"><span>Q:还需要解释为什么哈希最好是O（1）？</span></a></h2><p>哈希查找 <strong>最好是 O(1)</strong>，核心原因是：</p><hr><h2 id="_1-哈希直接定位存储位置" tabindex="-1"><a class="header-anchor" href="#_1-哈希直接定位存储位置"><span><strong>1. 哈希直接定位存储位置</strong></span></a></h2><ul><li>当你把 <code>&quot;小明&quot;</code> 作为键插入哈希表时，会先通过<strong>哈希函数</strong>计算一个整数（哈希值）。</li><li>哈希值再对<strong>桶数量</strong>取模，就能得到<strong>存储桶索引</strong>（类似于数组下标）。</li><li>这样，<strong>查找的时候</strong>对 <code>&quot;小明&quot;</code> 再做一次相同的哈希计算，就能<strong>直接跳到它所在的桶</strong>。</li></ul><p>这个过程不需要像线性表那样从头到尾扫描，而是“一步到位”，所以<strong>理论上是常数时间 O(1)</strong>。</p><hr><h2 id="_2-平均桶里元素很少" tabindex="-1"><a class="header-anchor" href="#_2-平均桶里元素很少"><span><strong>2. 平均桶里元素很少</strong></span></a></h2><ul><li>如果哈希函数分布均匀、并且负载因子（<code>元素个数 / 桶数</code>）保持合理，<strong>每个桶平均只有 0~1 个元素</strong>。</li><li>这样查找时，除了计算哈希值（O(1)）外，只需要在桶里做极少量的键比较（O(1)）。</li><li>所以平均复杂度就保持在 O(1)。</li></ul><hr><h2 id="_3-哈希计算本身是常数时间" tabindex="-1"><a class="header-anchor" href="#_3-哈希计算本身是常数时间"><span><strong>3. 哈希计算本身是常数时间</strong></span></a></h2><ul><li>常见的哈希函数（如 Python 的 <code>hash()</code>、Java 的 <code>hashCode()</code>）在键大小固定或可视为常量的情况下，计算时间不依赖于数据量。</li><li>因此哈希计算的时间复杂度是 O(1)。</li></ul><hr><h2 id="_4-为什么不是总是-o-1" tabindex="-1"><a class="header-anchor" href="#_4-为什么不是总是-o-1"><span><strong>4. 为什么不是总是 O(1)</strong></span></a></h2><p>哈希表 O(1) 是 <strong>平均情况</strong>，而不是无条件保证：</p><ul><li>如果哈希冲突严重（很多键落在同一个桶），就需要在桶里线性查找 → O(n)。</li><li>极端情况下（哈希函数很差或者有人恶意制造碰撞），会退化成链表查找。</li></ul><hr><p>✅ <strong>一句话总结</strong>：<br> 哈希表在“理想”条件下只需<strong>一次哈希运算 + 一次数组索引</strong>就能找到数据，所以最好情况下是 O(1)。</p><hr><p>我可以帮你画一个<strong>数组 vs 哈希表 O(1) 查找的内存访问路径图</strong>，让你直观看到为什么它快。<br> 你需要我画吗？这样比文字更容易记住。</p><h2 id="q-用最简单的例子-举例说明" tabindex="-1"><a class="header-anchor" href="#q-用最简单的例子-举例说明"><span>Q:用最简单的例子，举例说明</span></a></h2><p>好，那我用一个<strong>最简单、直观</strong>的例子来说明为什么哈希查找最好是 O(1)：</p><hr><h2 id="例子-查找-小明-的年龄" tabindex="-1"><a class="header-anchor" href="#例子-查找-小明-的年龄"><span><strong>例子：查找“小明”的年龄</strong></span></a></h2><p>我们有一个哈希表（字典）：</p><table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>张三</td><td>26</td></tr><tr><td>老王</td><td>60</td></tr><tr><td>小明</td><td>5</td></tr></tbody></table><hr><h3 id="步骤-1-计算哈希值" tabindex="-1"><a class="header-anchor" href="#步骤-1-计算哈希值"><span><strong>步骤 1：计算哈希值</strong></span></a></h3><p>假设哈希函数是：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>hash(&quot;小明&quot;) = 123456</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h3 id="步骤-2-找到桶位置" tabindex="-1"><a class="header-anchor" href="#步骤-2-找到桶位置"><span><strong>步骤 2：找到桶位置</strong></span></a></h3><p>桶数量假设是 10 个：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>index = 123456 % 10 = 6</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这意味着 <code>&quot;小明&quot;</code> 的数据被放在 <strong>桶 6</strong>（第 6 号位置）。</p><hr><h3 id="步骤-3-直接访问桶" tabindex="-1"><a class="header-anchor" href="#步骤-3-直接访问桶"><span><strong>步骤 3：直接访问桶</strong></span></a></h3><p>查找 <code>&quot;小明&quot;</code> 时，我们：</p><ol><li>再算一次 <code>hash(&quot;小明&quot;) = 123456</code></li><li><code>index = 123456 % 10 = 6</code></li><li><strong>直接跳到第 6 号桶</strong> → 找到 <code>&quot;小明&quot;: 5</code>。</li></ol><hr><h3 id="时间复杂度分析" tabindex="-1"><a class="header-anchor" href="#时间复杂度分析"><span><strong>时间复杂度分析</strong></span></a></h3><ul><li>哈希计算：O(1)（假设字符串长度很短且固定）</li><li>桶访问：O(1)（数组下标访问）</li><li>桶内比较：O(1)（平均情况下桶很短）</li></ul><p>所以 <strong>总共 O(1)</strong>。<br> 不管表里有 3 个元素，还是 300 万个元素，查找 <code>&quot;小明&quot;</code> 都是 <strong>固定步骤</strong>。</p><hr><p>如果你愿意，我可以帮你画一个<strong>小明定位到桶 6 的示意图</strong>，一眼就能看出为什么这是 O(1)。<br> 你想让我画吗？这样记忆会特别牢。</p><h2 id="q-hash-小明-123456的hash值是怎么算出来的" tabindex="-1"><a class="header-anchor" href="#q-hash-小明-123456的hash值是怎么算出来的"><span>Q:hash(&quot;小明&quot;) = 123456的hash值是怎么算出来的</span></a></h2><p>哈希值 <code>123456</code> 只是我刚才为了举例随便编的数字，真实计算是由<strong>哈希函数</strong>根据字符串的内容一步步算出来的。<br> 我给你一个最简单的<strong>手工可算</strong>的例子，你就能直观理解。</p><hr><h2 id="例子-手工算-小明-的哈希值" tabindex="-1"><a class="header-anchor" href="#例子-手工算-小明-的哈希值"><span><strong>例子：手工算 <code>&quot;小明&quot;</code> 的哈希值</strong></span></a></h2><p>假设我们的哈希函数规则很简单：</p><ol><li><p>把每个字符转换成它的 Unicode 编码值</p></li><li><p>用一个公式把这些值结合起来，例如：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>hash = 0</span></span>\n<span class="line"><span>对每个字符 c：</span></span>\n<span class="line"><span>    hash = hash * 31 + Unicode(c)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（31 是常见的哈希乘子，很多语言用它，比如 Java 的 <code>String.hashCode()</code>）</p></li></ol><hr><h3 id="步骤-1-unicode-编码" tabindex="-1"><a class="header-anchor" href="#步骤-1-unicode-编码"><span><strong>步骤 1：Unicode 编码</strong></span></a></h3><ul><li><code>&quot;小&quot;</code> → <code>23567</code></li><li><code>&quot;明&quot;</code> → <code>26126</code></li></ul><hr><h3 id="步骤-2-代入公式" tabindex="-1"><a class="header-anchor" href="#步骤-2-代入公式"><span><strong>步骤 2：代入公式</strong></span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>初始 hash = 0</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>处理 &quot;小&quot;:</span></span>\n<span class="line"><span>hash = 0 * 31 + 23567 = 23567</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>处理 &quot;明&quot;:</span></span>\n<span class="line"><span>hash = 23567 * 31 + 26126</span></span>\n<span class="line"><span>     = 730577 + 26126</span></span>\n<span class="line"><span>     = 756703</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以在这个简单规则下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>hash(&quot;小明&quot;) = 756703</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><hr><h3 id="步骤-3-取模映射到桶" tabindex="-1"><a class="header-anchor" href="#步骤-3-取模映射到桶"><span><strong>步骤 3：取模映射到桶</strong></span></a></h3><p>如果桶数是 10：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-"><span class="line"><span>index = 756703 % 10 = 3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>就能直接定位到 <strong>桶 3</strong>。</p><hr><p>✅ <strong>关键点</strong>：</p><ul><li>真正的哈希函数在不同语言中可能更复杂（会混合位运算、质数乘法等）来减少冲突。</li><li>但核心思想是：<strong>把一段数据变成一个固定范围的整数</strong>，用于快速定位存储位置。</li></ul><hr><p>如果你愿意，我可以帮你画一个**“小明” → Unicode → 哈希值 → 桶**的流程图，让你一下就能记住哈希的工作原理。<br> 要我画吗？这样你就可以一眼看懂了。</p><h2 id="q-谁命名的桶" tabindex="-1"><a class="header-anchor" href="#q-谁命名的桶"><span>Q:谁命名的桶</span></a></h2><p>“桶”这个说法（bucket）并不是某个人发明的专有名词，而是<strong>计算机科学里的一种形象化比喻</strong>，最早可以追溯到早期的哈希表和散列算法论文中。</p><hr><h2 id="_1-英文原词是-bucket" tabindex="-1"><a class="header-anchor" href="#_1-英文原词是-bucket"><span><strong>1. 英文原词是 &quot;bucket&quot;</strong></span></a></h2><ul><li>直译就是<strong>水桶</strong>、<strong>容器</strong>。</li><li>计算机里用它来表示<strong>一个可以存放若干元素的存储单元</strong>。</li><li>因为哈希表中，一个索引位置可能存放不止一个元素（冲突时），所以这个位置就像一个小桶，可以装多个数据。</li></ul><hr><h2 id="_2-来源背景" tabindex="-1"><a class="header-anchor" href="#_2-来源背景"><span><strong>2. 来源背景</strong></span></a></h2><ul><li>在 1960 年代，哈希表（hash table）的理论被正式提出（例如 Donald Knuth 在《The Art of Computer Programming》第一卷就有详细讲解）。</li><li>当时在讲解<strong>散列冲突</strong>的解决方案时，研究人员用 &quot;bucket&quot; 来形容一个<strong>存储相同哈希索引下所有记录的集合</strong>。</li><li>这个词形象又好记，就被编程界沿用至今。</li></ul><hr><h2 id="_3-为什么不用-格子-或-槽" tabindex="-1"><a class="header-anchor" href="#_3-为什么不用-格子-或-槽"><span><strong>3. 为什么不用“格子”或“槽”</strong></span></a></h2><ul><li>英文里其实也有人用 <strong>slot</strong>（槽）、<strong>cell</strong>（格子）来表示数组位置。</li><li>但<strong>slot/cell</strong>通常表示只能放一个值，而<strong>bucket</strong>天然有“装多个东西”的含义，刚好对应<strong>链地址法</strong>这种每个位置可能有多个元素的情况。</li></ul><hr><h2 id="_4-现在的用法" tabindex="-1"><a class="header-anchor" href="#_4-现在的用法"><span><strong>4. 现在的用法</strong></span></a></h2><ul><li>在数据结构、数据库（比如哈希索引）、甚至分布式存储（像 Amazon S3 的 bucket）里，“bucket”都用来表示一个数据集合的容器。</li><li>所以“桶”是个约定俗成的叫法，不是某个人的专利命名。</li></ul><hr><p>如果你想的话，我可以帮你找一下<strong>1960~1970 年间最早出现 bucket 这个术语的哈希表论文出处</strong>，这样能追溯到它第一次被正式使用的历史记录。<br> 你要我帮你查吗？这样可以直接看到它的“出生证明”。</p>',91)]))}]]),r=JSON.parse('{"path":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87.html","title":"哈希表查找效率","lang":"zh-CN","frontmatter":{"tag":["AI_GEN"],"description":"哈希表查找效率 Q:数组的查询效率可以到O1，因为它是顺序存储的。字典的是key,value用hash方式存储的。比如{张三，26}，{老王，60}，{小明， 5}. 以hash的数据结构，我要查小明，效率是O1还是O(n)? 如果字典是用哈希表实现的，那么平均情况下查找 \\"小明\\" 这样的键的时间复杂度是 O(1)，因为它会直接通过哈希函数把键映射到一...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"哈希表查找效率\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-15T05:20:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Runner2011\\",\\"url\\":\\"https://runner2011.github.io\\"}]}"],["meta",{"property":"og:url","content":"https://runner2011.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87.html"}],["meta",{"property":"og:site_name","content":"Runner2011 blog"}],["meta",{"property":"og:title","content":"哈希表查找效率"}],["meta",{"property":"og:description","content":"哈希表查找效率 Q:数组的查询效率可以到O1，因为它是顺序存储的。字典的是key,value用hash方式存储的。比如{张三，26}，{老王，60}，{小明， 5}. 以hash的数据结构，我要查小明，效率是O1还是O(n)? 如果字典是用哈希表实现的，那么平均情况下查找 \\"小明\\" 这样的键的时间复杂度是 O(1)，因为它会直接通过哈希函数把键映射到一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-15T05:20:56.000Z"}],["meta",{"property":"article:tag","content":"AI_GEN"}],["meta",{"property":"article:modified_time","content":"2025-08-15T05:20:56.000Z"}]]},"git":{"createdTime":1755235256000,"updatedTime":1755235256000,"contributors":[{"name":"runner2011","username":"runner2011","email":"chenjfsea@gmail.com","commits":1,"url":"https://github.com/runner2011"}]},"readingTime":{"minutes":6.92,"words":2076},"filePathRelative":"posts/计算机基础/数据结构算法/哈希表查找效率.md","excerpt":"\\n<h2>Q:数组的查询效率可以到O1，因为它是顺序存储的。字典的是key,value用hash方式存储的。比如{张三，26}，{老王，60}，{小明， 5}. 以hash的数据结构，我要查小明，效率是O1还是O(n)?</h2>\\n<p>如果字典是用哈希表实现的，那么<strong>平均情况下</strong>查找 <code>\\"小明\\"</code> 这样的键的时间复杂度是 <strong>O(1)</strong>，因为它会直接通过哈希函数把键映射到一个存储位置，然后一步就能找到对应的值。</p>\\n<p>但是有几点需要注意：</p>\\n<ol>\\n<li>\\n<p><strong>平均 O(1)，最坏 O(n)</strong></p>\\n<ul>\\n<li>如果哈希函数分布均匀、冲突少，那么查找就是常数时间。</li>\\n<li>如果哈希冲突非常严重（比如所有 key 都映射到同一个位置），查找就会退化成线性查找 O(n)。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>哈希表查找的过程</strong></p>\\n<ul>\\n<li>对键（比如 <code>\\"小明\\"</code>）计算哈希值 → 找到哈希桶的位置 → 在该桶中比较键（因为可能冲突） → 返回值。</li>\\n<li>桶里如果只有一个元素，就是一步找到；如果有多个元素，就要在桶里线性查找。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>和数组的区别</strong></p>\\n<ul>\\n<li>数组下标访问是真正的 O(1) 且最坏也是 O(1)，因为它直接通过 <code>基址 + index * 元素大小</code> 计算内存位置。</li>\\n<li>哈希表的 O(1) 是概率意义上的，依赖于哈希函数质量和负载因子（load factor）。</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}')}}]);