---
tag:
  - AI_GEN


---
# 贪心算法，动态规划

*   **贪心算法**：像一个人爬山，每次都选最陡的路，可能错过真正的顶峰。
*   **动态规划**：像一群人分头探索所有路径，最后汇总最优路线

动态规划：计算每一个子问题，并记录子问题的结果。**核心：子问题只算一遍。** 这个方式来降复杂度，而[NP问题](../P和NP问题.md)通常不能拆分成**可复用的子问题**，导致复杂度太高

贪心算法：每次取最解决的结果，一条路走到黑

## 贪心算法的问题
  - 是一种快速接近最优解的办法，但可能不是最优解
  - 动态规划因为考虑了全局（在满足某些条件，暂时不表），可以求出最优解

举个例子：

场景设定：
您要去菜市场买菜，家里锅只能煮最多10斤菜，您带了一个“布兜”，最多也只能装10斤。

市场里**只有这么多重量**的食材：
  | 菜名  | 重量（斤） | 美味度（分） |
| --- | ----- | ------ |
| 西红柿 | 2斤    | 3分     |
| 土豆  | 3斤    | 4分     |
| 鸡蛋  | 4斤    | 5分     |
| 牛肉  | 5斤    | 8分     |

一种常见的满足直觉的算法是，我先买$性价比=美味度/重量$最高的食材，以此类推。分别是牛肉（1.6），西红柿（1.5），土豆（1.33），鸡蛋（1.25）。
10斤可以得15分美味度。这个就是最优解。然后把限制改到9斤时，这个算法，只能买牛肉+西红柿（9分），错过了牛肉+鸡蛋（13分）的最优解。**这个算法就叫贪心算法**

## 动态规划
**runner2011**: 
简单说动态规划是把大问题拆解成子问题，求得子问题的最优解，从而得到大问题最优解。也是一种**递归**的思想。
换句话说，
$$R_{t+1}=R_t + r$$
只要$R_t$是最优解，r是t+1这一步最优解，那$R_{t+1}$就是最优解（最大值）。这个就是[贝尔曼方程](https://en.wikipedia.org/wiki/Bellman_equation)和动态规划的思想。Richard E. Bellman是二者发明人。
强化学习MDP(有限马尔可夫决策过程)最大化价值函数也是用这一方法。

一、列举所有可行组合（≤10斤）

把所有可能组合算一遍更直观：
| 组合        | 总重量 | 总美味度   |
| --------- | --- | ------ |
| 西红柿       | 2   | 3      |
| 土豆        | 3   | 4      |
| 鸡蛋        | 4   | 5      |
| 牛肉        | 5   | 8      |
| 西红柿+土豆    | 5   | 7      |
| 西红柿+鸡蛋    | 6   | 8      |
| 西红柿+牛肉    | 7   | 11     |
| 土豆+鸡蛋     | 7   | 9      |
| 土豆+牛肉     | 8   | 12     |
| 鸡蛋+牛肉     | 9   | 13     |
| 西红柿+土豆+鸡蛋 | 9   | 12     |
| 西红柿+土豆+牛肉 | 10  | 15 ←最大 |
| 西红柿+鸡蛋+牛肉 | 11  | 超重     |
| 土豆+鸡蛋+牛肉  | 12  | 超重     |
| 全部        | 14  | 超重     |

最优解：
```
西红柿 + 土豆 + 牛肉
重量 = 2+3+5 = 10
美味度 = 3+4+8 = 15
```
最优解重量是：5+3+2。 8+2和7+3拆解成最小子问题后都是5+3+2. 而6+4继续拆成4+2+2，在0-1背包问题（物品只能选一次）不合法，5+5同样不合法。
前面提到，因为拆解成了最优子问题，而每个子问题只要是最优解，最后总问题就是最优解。

 **题外话**：
> 动态规划也可以求最短路径，那和Dijkstra算法有什么区别？
> 大概区别（不一定对）：
> - 动态规划适用于DAG（有向无环图），Dijkstra无此要求
> - 限制在 DAG 中，DP 最短路径和 Dijkstra 的状态转移完全一致，但DP 使用拓扑顺序，Dijkstra 使用贪心顺序，算法思想仍不同。




## 性能

| 维度       | 贪心算法             | 动态规划                        |
| :------- | :--------------- | :-------------------------- |
| **时间效率** | 快（`O(amount)`）   | 慢（`O(amount × coin_types)`） |
| **空间效率** | 低（`O(1)`）        | 高（`O(amount)`）              |
| **解的质量** | 可能非最优（如 `4,1,1`） | 保证最优（如 `3,3`）               |
| **适用场景** | 问题满足贪心性质时        | 通用性强，但需要更多计算                |

