---
date: 2025-08-12
tag:
  - Math
  - AI_GEN

---

# 怎么判断质数

判断一个数是不是质数（质数=只能被 1 和它本身整除的自然数）的方法有快有慢，取决于这个数有多大：

---

## **1. 小范围（几十万以内）**

直接用**试除法**，并加上几个优化：

1. **小于 2 → 不是质数**；2 和 3 → 质数。
2. 如果能被 2 或 3 整除 → 不是质数。
3. 从 5 开始试除到 `√n`，只检查形如 `6k ± 1` 的数：

   ```python
   import math
   def is_prime(n):
       if n < 2:
           return False
       if n in (2, 3):
           return True
       if n % 2 == 0 or n % 3 == 0:
           return False
       limit = int(math.isqrt(n))
       i = 5
       while i <= limit:
           if n % i == 0 or n % (i + 2) == 0:
               return False
           i += 6
       return True
   ```

   这样能减少大约 2/3 的除法次数。

---

## **2. 大范围（几百万 \~ 十亿）**

* 用 **筛法（Sieve of Eratosthenes）** 先生成所有质数表，再查表判断。
* 或者只生成到 `√n` 的质数表，再用这些质数试除目标数。

---

## **3. 超大范围（超过 10¹² 甚至 10¹⁸）**

* 常用 **Miller–Rabin 素性测试**（快速概率算法，速度非常快，错误概率极低，可通过多次随机基数测试降低到几乎 0）。
* 对 64 位整数，甚至可以用固定几个基数做 Miller–Rabin 来得到**确定性**判断。

示例（64 位整数确定性版本）：

```python
def is_prime_mr(n):
    if n < 2:
        return False
    for p in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37):
        if n % p == 0:
            return n == p

    # 写成 d*2^s 形式
    d, s = n - 1, 0
    while d % 2 == 0:
        d //= 2
        s += 1

    # Miller–Rabin 检测
    def check(a):
        x = pow(a, d, n)
        if x == 1 or x == n - 1:
            return True
        for _ in range(s - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                return True
        return False

    # 对 64 位整数确定性基数
    for a in (2, 325, 9375, 28178, 450775, 9780504, 1795265022):
        if a % n == 0:
            continue
        if not check(a):
            return False
    return True
```

这个版本在 64 位整数范围内**绝对正确**，而且比试除法快很多。

> Quiz 手机号质因数分解
