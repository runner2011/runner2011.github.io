---
date: 2026-01-22
tag:
  - Math
  - AI_GEN

---

# 浮点计数法

## 为什么2^-1, 2^-2, 2^-3 ... 2^-n之和的方式，可以‘近似’表示任何尾数，原因是什么

> 浮点数最终存储的值：存储的二进制尾数代表的值其实是：$$0.5 + 0.25 + 0.125 + 0.0625 + \dots$$

这是一个极其深刻的数学问题，触及了**数制系统的本质**。

之所以  的组合可以“近似”表示任何小数，是因为这种方式本质上是一个 **“二分逼近” (Binary Approximation)** 的过程。

你可以把它想象成**用一把只有“对半切”功能的刀，去切一块长度为 1 的蛋糕，试图切出你想要的任意长度。**

以下是三个维度的解释：直观逻辑、几何原理和数学极限。

---

### 1. 直观类比：天平与砝码

想象你有一个天平，左边放着你想要表示的任意重量（比如 0.7 吨）。
你的右边只有一套特殊的**砝码**，重量分别是：

*  (0.5)
*  (0.25)
*  (0.125)
*  (0.0625)
* ...以此类推，每个都是前一个的一半。

**操作逻辑（贪心算法）：**

1. **放 0.5 的砝码**：如果总重没超，就留着（记为 1）；如果超了，就拿掉（记为 0）。
2. **放 0.25 的砝码**：在剩下的基础上，再放 0.25，没超就留着，超了拿掉。
3. **重复下去**...

只要你的砝码分得足够细（ 足够大），你就可以把右边的总重量调整到**无限接近**左边的任意重量。

* **FP16 的局限**：FP16 只有 10 个这样的砝码（10位尾数）。用这 10 个砝码凑不出来的重量，就只能“四舍五入”了，这就是**精度丢失**。

---

### 2. 几何解释：数轴切割

这实际上是对  区间进行不断的**区间二分**。

* **第 1 刀 ()**：把 0 到 1 分成两半，刻度是 0.5。你现在能表示 {0, 0.5, 1}。
* **第 2 刀 ()**：把剩下的每段再分两半，增加刻度 0.25, 0.75。现在能精确表示 {0, 0.25, 0.5, 0.75, 1}。
* **第 3 刀 ()**：增加 0.125, 0.375...

**原因核心：**
随着  的增加，两个刻度之间的**间隙 (Gap)** 会以  的速度迅速缩小。

* 当  (FP16) 时，间隙是 。
* 当  (FP32) 时，间隙是 。

**虽然间隙永远存在（除非  无穷大），但在有限的精度要求下，这个间隙小到可以忽略不计，这就是“近似”的含义。**

---

### 3. 数学原理：级数与完备性

从数学上讲，这利用了**几何级数 (Geometric Series)** 的性质。

我们知道：


这意味着，如果你被允许使用无限多个位，你可以填满 0 到 1 之间的**所有空间**。

对于任意实数 ，我们总能找到一个二进制序列 （其中  为 0 或 1），使得：


**为什么有些数是“无限循环”的？**
这就好比在十进制里，用  去凑 。

* 
* 因为 3 不能整除 10 的因子（2和5）。

同理，在二进制里，如果一个分数的**分母**包含除了 2 以外的质因子（比如 0.1 的分数是 ，分母含有 5），那么它在二进制里就一定是**无限循环小数**。
因为你永远无法用有限个“2的幂次之和”精确凑出它，只能无限逼近。

### 总结

这种表示法之所以有效，是因为**2的幂次级数收敛**，且随着幂次降低，其覆盖网格的密度呈指数级增加。

* **对于计算机**：它只需要判断“要不要加这个权重”（0或1），这是电路最喜欢的开关操作。
* **对于数学**：它保证了只要位数足够多，误差可以小到任意给定的  范围内。